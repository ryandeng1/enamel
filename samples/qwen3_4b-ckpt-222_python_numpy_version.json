[
  [
    "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if len(numbers) < 2:\n        return False\n    sorted_nums = sorted(numbers)\n    for i in range(1, len(sorted_nums)):\n        if sorted_nums[i] - sorted_nums[i-1] < threshold:\n            return True\n    return False",
    "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    n = len(numbers)\n    if n < 2:\n        return False\n    sorted_numbers = sorted(numbers)\n    for i in range(n - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False",
    "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i-1] < threshold:\n            return True\n    return False"
  ],
  [
    "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    cleaned = paren_string.replace(' ', '')\n    result = []\n    current_depth = 0\n    start_index = 0\n    for i, c in enumerate(cleaned):\n        if c == '(':\n            current_depth += 1\n        elif c == ')':\n            current_depth -= 1\n        if current_depth == 0:\n            result.append(cleaned[start_index:i+1])\n            start_index = i + 1\n    return result",
    "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    s = paren_string.replace(\" \", \"\")\n    groups = []\n    balance = 0\n    start = 0\n    for i, c in enumerate(s):\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        if balance == 0:\n            groups.append(s[start:i+1])\n            start = i + 1\n    return groups",
    "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    current_group = []\n    current_open = 0\n    result = []\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            current_open += 1\n            current_group.append(char)\n        elif char == ')':\n            current_open -= 1\n            current_group.append(char)\n        if current_open == 0:\n            result.append(''.join(current_group))\n            current_group = []\n    return result"
  ],
  [
    "def truncate_number(number: float) -> float:\n    return number % 1",
    "def truncate_number(number: float) -> float:\n    return number - int(number)",
    "def truncate_number(number: float) -> float:\n    return number % 1"
  ],
  [
    "from typing import List\nfrom itertools import accumulate\n\ndef below_zero(operations: List[int]) -> bool:\n    for balance in accumulate(operations):\n        if balance < 0:\n            return True\n    return False",
    "balance = 0\nfor op in operations:\n    balance += op\n    if balance < 0:\n        return True\nreturn False",
    "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"
  ],
  [
    "import numpy as np\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    arr = np.array(numbers)\n    return np.mean(np.abs(arr - np.mean(arr)))",
    "from typing import List\nimport numpy as np\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    arr = np.array(numbers)\n    return np.mean(np.abs(arr - np.mean(arr)))",
    "from typing import List\nimport numpy as np\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    arr = np.array(numbers)\n    return np.mean(np.abs(arr - arr.mean()))"
  ],
  [
    "from typing import List\nimport itertools\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    return list(itertools.chain.from_iterable((x, delimeter) for x in numbers))[:-1] if numbers else []",
    "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        result.append(delimeter)\n        result.append(numbers[i])\n    return result",
    "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    return [numbers[0]] + [x for num in numbers[1:] for x in (delimeter, num)]"
  ],
  [
    "import itertools\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    return [max(itertools.accumulate((1 if c == '(' else -1 for c in group), initial=0)) for group in paren_string.split()]",
    "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    results = []\n    for group in groups:\n        current = 0\n        max_depth = 0\n        for c in group:\n            current += 1 if c == '(' else -1\n            if current > max_depth:\n                max_depth = current\n        results.append(max_depth)\n    return results",
    "def parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        current = 0\n        max_depth = 0\n        for c in group:\n            if c == '(':\n                current += 1\n                if current > max_depth:\n                    max_depth = current\n            else:\n                current -= 1\n        result.append(max_depth)\n    return result"
  ],
  [
    "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]",
    "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    sub = substring\n    return [s for s in strings if sub in s]",
    "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"
  ],
  [
    "import numpy as np\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    arr = np.array(numbers)\n    return (int(np.sum(arr)), int(np.prod(arr)))",
    "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    total = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    return (total, product)",
    "from typing import List, Tuple\nimport numpy as np\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    arr = np.array(numbers)\n    return (np.sum(arr), np.product(arr))"
  ],
  [
    "from typing import List, Tuple\nimport numpy as np\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    return np.cummax(np.array(numbers)).tolist()",
    "import numpy as np\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    return np.cummax(np.array(numbers)).tolist()",
    "import numpy as np\nfrom typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    return np.cummax(np.array(numbers)).tolist()"
  ],
  [
    "def make_palindrome(string: str) -> str:\n    if not string:\n        return string\n    rev_s = string[::-1]\n    T = rev_s + '#' + string\n    n = len(T)\n    pi = [0] * n\n    k = 0\n    for i in range(1, n):\n        while k > 0 and T[k] != T[i]:\n            k = pi[k-1]\n        if T[k] == T[i]:\n            k += 1\n        pi[i] = k\n    L = pi[-1]\n    return string + string[:len(string) - L][::-1]",
    "import numpy as np\n\ndef make_palindrome(string: str) -> str:\n    n = len(string)\n    if n == 0:\n        return string\n    s_arr = np.array([ord(c) for c in string], dtype=np.int32)\n    rev_s_arr = s_arr[::-1]\n    for k in range(n, 0, -1):\n        suffix = s_arr[-k:]\n        if np.all(suffix == rev_s_arr[:k]):\n            return string + string[:n - k][::-1]\n    return string",
    "def make_palindrome(string: str) -> str:\n    n = len(string)\n    if n == 0:\n        return string\n    for k in range(n, 0, -1):\n        for j in range(k // 2):\n            if string[n - k + j] != string[n - 1 - j]:\n                break\n        else:\n            return string + string[:n - k][::-1]\n    return string + string[:n-1][::-1]"
  ],
  [
    "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    return ''.join('1' if x != y else '0' for x, y in zip(a, b))",
    "import numpy as np\n\ndef string_xor(a: str, b: str) -> str:\n    a_arr = np.fromiter((int(c) for c in a), dtype=np.int8)\n    b_arr = np.fromiter((int(c) for c in b), dtype=np.int8)\n    xor_arr = a_arr ^ b_arr\n    return ''.join(str(x) for x in xor_arr)",
    "def string_xor(a: str, b: str) -> str:\n    return ''.join(['1' if x != y else '0' for x, y in zip(a, b)])"
  ],
  [
    "def longest(strings: List[str]) -> Optional[str]:\n    return max(strings, key=len) if strings else None",
    "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)",
    "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)"
  ],
  [
    "def greatest_common_divisor(a: int, b: int) -> int:\n    a = abs(a)\n    b = abs(b)\n    while b:\n        a, b = b, a % b\n    return a",
    "def greatest_common_divisor(a: int, b: int) -> int:\n    a = abs(a)\n    b = abs(b)\n    while b:\n        a, b = b, a % b\n    return a",
    "def greatest_common_divisor(a: int, b: int) -> int:\n    a = abs(a)\n    b = abs(b)\n    while b:\n        a, b = b, a % b\n    return a"
  ],
  [
    "return [string[:i] for i in range(1, len(string) + 1)]",
    "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:i] for i in range(1, len(string) + 1)]",
    "def all_prefixes(string: str) -> List[str]:\n    return [string[:i+1] for i in range(len(string))]"
  ],
  [
    "def string_sequence(n: int) -> str:\n    return \" \".join(map(str, range(n + 1)))",
    "def string_sequence(n: int) -> str:\n    return ' '.join([str(i) for i in range(n + 1)])",
    "def string_sequence(n: int) -> str:\n    return ' '.join([str(i) for i in range(n + 1)])"
  ],
  [
    "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))",
    "def count_distinct_characters(string: str) -> int:\n    return len({c.lower() for c in string})",
    "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))"
  ],
  [
    "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[token] for token in music_string.split()]",
    "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[token] for token in music_string.split()]",
    "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    tokens = music_string.split()\n    mapping = {'o': 4, 'o|': 2, '.|': 1}\n    return [mapping[token] for token in tokens]"
  ],
  [
    "def how_many_times(string: str, substring: str) -> int:\n    n = len(string)\n    m = len(substring)\n    count = 0\n    start = 0\n    while start <= n - m:\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    return count",
    "def how_many_times(string: str, substring: str) -> int:\n    if not substring:\n        return 0\n    count = 0\n    start = 0\n    n = len(string)\n    m = len(substring)\n    while start <= n - m:\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    return count",
    "def how_many_times(string: str, substring: str) -> int:\n    count = 0\n    start = 0\n    while True:\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    return count"
  ],
  [
    "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    word_to_num = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    words = numbers.split()\n    sorted_words = sorted(words, key=lambda x: word_to_num[x])\n    return ' '.join(sorted_words)",
    "def sort_numbers(numbers: str) -> str:\n    mapping = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted(numbers.split(), key=lambda x: mapping[x]))",
    "from typing import List\n\nword_list = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\nword_to_num = {word: i for i, word in enumerate(word_list)}\n\ndef sort_numbers(numbers: str) -> str:\n    words = numbers.split()\n    nums = [word_to_num[word] for word in words]\n    nums.sort()\n    return ' '.join(word_list[n] for n in nums)"
  ],
  [
    "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_nums = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = None\n    for i in range(len(sorted_nums) - 1):\n        diff = sorted_nums[i+1] - sorted_nums[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_nums[i], sorted_nums[i+1])\n    return closest_pair",
    "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_nums = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    for i in range(len(sorted_nums) - 1):\n        diff = sorted_nums[i+1] - sorted_nums[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_nums[i], sorted_nums[i+1])\n    return closest_pair",
    "from typing import List, Tuple\nimport numpy as np\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    arr = np.array(numbers)\n    sorted_arr = np.sort(arr)\n    diffs = np.diff(sorted_arr)\n    min_idx = np.argmin(diffs)\n    return (sorted_arr[min_idx], sorted_arr[min_idx + 1])"
  ],
  [
    "from typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    arr = np.array(numbers)\n    min_val = arr.min()\n    max_val = arr.max()\n    return (arr - min_val) / (max_val - min_val).tolist()",
    "from typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    arr = np.array(numbers)\n    min_val = arr.min()\n    max_val = arr.max()\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return (arr - min_val) / (max_val - min_val).tolist()",
    "from typing import List\nimport numpy as np\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    arr = np.array(numbers)\n    min_val = np.min(arr)\n    max_val = np.max(arr)\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return (arr - min_val) / (max_val - min_val).tolist()"
  ],
  [
    "def filter_integers(values: List[Any]) -> List[int]:\n    return [x for x in values if type(x) is int]",
    "def filter_integers(values: List[Any]) -> List[int]:\n    int_type = int\n    return [v for v in values if type(v) == int_type]",
    "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [x for x in values if type(x) == int]"
  ],
  [
    "def strlen(string: str) -> int:\n    return len(string)",
    "def strlen(string: str) -> int:\n    return len(string)",
    "def strlen(string: str) -> int:\n    return len(string)"
  ],
  [
    "def largest_divisor(n: int) -> int:\n    if n % 2 == 0:\n        return n // 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return n // i\n        i += 2\n    return 1",
    "def largest_divisor(n: int) -> int:\n    if n % 2 == 0:\n        return n // 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return n // i\n        i += 2\n    return 1",
    "def largest_divisor(n: int) -> int:\n    if n % 2 == 0:\n        return n // 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return n // i\n        i += 2\n    return 1"
  ],
  [
    "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    while n % 3 == 0:\n        factors.append(3)\n        n //= 3\n    f = 5\n    while f * f <= n:\n        while n % f == 0:\n            factors.append(f)\n            n //= f\n        while n % (f + 2) == 0:\n            factors.append(f + 2)\n            n //= (f + 2)\n        f += 6\n    if n > 1:\n        factors.append(n)\n    return factors",
    "from typing import List\nimport numpy as np\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    # Factor out all 2s\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    # Factor out all 3s\n    while n % 3 == 0:\n        factors.append(3)\n        n //= 3\n    # Now n is not divisible by 2 or 3\n    f = 5\n    while f * f <= n:\n        while n % f == 0:\n            factors.append(f)\n            n //= f\n        while n % (f + 2) == 0:\n            factors.append(f + 2)\n            n //= (f + 2)\n        f += 6\n    if n > 1:\n        factors.append(n)\n    return factors",
    "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            factors.append(f)\n            n //= f\n        else:\n            f += 2\n    if n > 1:\n        factors.append(n)\n    return factors"
  ],
  [
    "from typing import List\nfrom collections import defaultdict\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    freq = defaultdict(int)\n    for num in numbers:\n        freq[num] += 1\n    return [num for num in numbers if freq[num] == 1]",
    "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result",
    "def remove_duplicates(numbers: List[int]) -> List[int]:\n    seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result"
  ],
  [
    "def flip_case(string: str) -> str:\n    return string.swapcase()",
    "def flip_case(string: str) -> str:\n    return string.swapcase()",
    "def flip_case(string: str) -> str:\n    return string.swapcase()"
  ],
  [
    "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)",
    "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)",
    "def concatenate(strings: List[str]) -> str:\n    return ''.join(strings)"
  ],
  [
    "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]",
    "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    if not prefix:\n        return strings\n    return [s for s in strings if s.startswith(prefix)]",
    "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]"
  ],
  [
    "import numpy as np\n\ndef get_positive(l: list):\n    arr = np.array(l)\n    return arr[arr > 0].tolist()",
    "def get_positive(l: list):\n    return [x for x in l if x > 0]",
    "import numpy as np\n\ndef get_positive(l: list):\n    arr = np.array(l)\n    return arr[arr > 0].tolist()"
  ],
  [
    "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"
  ],
  [
    "import numpy as np\n\ndef find_zero(xs):\n    return np.roots(xs[::-1])[0]",
    "import numpy as np\n\ndef find_zero(xs: list):\n    coeffs = np.array(xs[::-1])\n    roots = np.roots(coeffs)\n    real_roots = [root.real for root in roots if np.isreal(root)]\n    return real_roots[0]",
    "import numpy as np\n\ndef find_zero(xs: list):\n    coeffs = xs[::-1]\n    roots = np.roots(coeffs)\n    real_roots = [root.real for root in roots if np.isreal(root)]\n    return min(real_roots)"
  ],
  [
    "def sort_third(l):\n    sorted_thirds = sorted(l[i] for i in range(0, len(l), 3))\n    return [sorted_thirds[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]",
    "def sort_third(l):\n    n = len(l)\n    third_elems = [l[i] for i in range(0, n, 3)]\n    third_elems.sort()\n    return [third_elems[i // 3] if i % 3 == 0 else l[i] for i in range(n)]",
    "def sort_third(l: list):\n    third_elems = [l[i] for i in range(0, len(l), 3)]\n    third_elems.sort()\n    return [third_elems[i // 3] if i % 3 == 0 else l[i] for i in range(len(l))]"
  ],
  [
    "def unique(l: list):\n    return sorted(set(l))",
    "import numpy as np\n\ndef unique(l):\n    return np.unique(l).tolist()",
    "def unique(l: list):\n    return sorted(set(l))"
  ],
  [
    "def max_element(l: list):\n    return max(l)",
    "import numpy as np\n\ndef max_element(l: list):\n    return np.array(l).max()",
    "def max_element(l: list):\n    return max(l)"
  ],
  [
    "def fizz_buzz(n: int):\n    total = 0\n    for i in range(11, n, 11):\n        total += str(i).count('7')\n    for i in range(13, n, 13):\n        if i % 11 != 0:\n            total += str(i).count('7')\n    return total",
    "def fizz_buzz(n):\n    total = 0\n    for i in range(11, n, 11):\n        total += str(i).count('7')\n    for i in range(13, n, 13):\n        total += str(i).count('7')\n    for i in range(143, n, 143):\n        total -= str(i).count('7')\n    return total",
    "def fizz_buzz(n: int):\n    total = 0\n    for i in range(11, n, 11):\n        total += str(i).count('7')\n    for i in range(13, n, 13):\n        total += str(i).count('7')\n    for i in range(143, n, 143):\n        total -= str(i).count('7')\n    return total"
  ],
  [
    "def sort_even(l):\n    evens = [l[i] for i in range(0, len(l), 2)]\n    odds = l[1::2]\n    evens_sorted = sorted(evens)\n    result = []\n    for e, o in zip(evens_sorted, odds):\n        result.append(e)\n        result.append(o)\n    if len(evens_sorted) > len(odds):\n        result.append(evens_sorted[-1])\n    return result",
    "def sort_even(l):\n    evens = sorted(l[::2])\n    odds = l[1::2]\n    n = len(l)\n    result = [0] * n\n    for i in range(len(evens)):\n        result[2*i] = evens[i]\n        if i < len(odds):\n            result[2*i + 1] = odds[i]\n    return result",
    "def sort_even(l):\n    evens = l[::2]\n    evens_sorted = sorted(evens)\n    return [evens_sorted[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]"
  ],
  [
    "def encode_cyclic(s: str):\n    return ''.join(\n        group[1:] + group[0] if len(group) == 3 else group\n        for group in (s[i:i+3] for i in range(0, len(s), 3))\n    )",
    "def encode_cyclic(s: str):\n    return ''.join(\n        (group[1:] + group[0]) if len(group) == 3 else group\n        for group in (s[i:i+3] for i in range((len(s) + 2) // 3))\n    )",
    "def encode_cyclic(s: str):\n    return ''.join(\n        (s[i+1] + s[i+2] + s[i]) if (i + 3 <= len(s)) else s[i:]\n        for i in range(0, len(s), 3)\n    )"
  ],
  [
    "def prime_fib(n: int):\n    a, b = 0, 1\n    count = 0\n    while count < n:\n        a, b = b, a + b\n        if a == 2:\n            count += 1\n            if count == n:\n                return a\n        elif a % 2 == 0:\n            continue\n        elif a < 3:\n            continue\n        else:\n            i = 3\n            while i * i <= a:\n                if a % i == 0:\n                    break\n                i += 2\n            else:\n                count += 1\n                if count == n:\n                    return a\n    return a",
    "def prime_fib(n: int):\n    def is_prime(x):\n        if x < 2:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        i = 3\n        while i * i <= x:\n            if x % i == 0:\n                return False\n            i += 2\n        return True\n\n    a, b = 0, 1\n    count = 0\n    k = 0\n    while count < n:\n        k += 1\n        a, b = b, a + b\n        if k == 3:\n            if is_prime(a):\n                count += 1\n                if count == n:\n                    return a\n        elif k == 4:\n            if is_prime(a):\n                count += 1\n                if count == n:\n                    return a\n        elif is_prime(k):\n            if is_prime(a):\n                count += 1\n                if count == n:\n                    return a\n    return a",
    "def prime_fib(n: int):\n    def is_prime(x):\n        if x < 2:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        i = 3\n        while i * i <= x:\n            if x % i == 0:\n                return False\n            i += 2\n        return True\n\n    count = 0\n    a, b = 0, 1\n    while count < n:\n        a, b = b, a + b\n        if a == 2:\n            count += 1\n            if count == n:\n                return a\n        elif a % 2 == 0:\n            continue\n        else:\n            if is_prime(a):\n                count += 1\n                if count == n:\n                    return a\n    return a"
  ],
  [
    "def triples_sum_to_zero(l):\n    n = len(l)\n    if n < 3:\n        return False\n    sorted_l = sorted(l)\n    for i in range(n - 2):\n        if sorted_l[i] + sorted_l[i + 1] + sorted_l[i + 2] > 0:\n            break\n        if sorted_l[i] + sorted_l[n - 2] + sorted_l[n - 1] < 0:\n            continue\n        left, right = i + 1, n - 1\n        while left < right:\n            s = sorted_l[i] + sorted_l[left] + sorted_l[right]\n            if s == 0:\n                return True\n            elif s < 0:\n                left += 1\n            else:\n                right -= 1\n    return False",
    "def triples_sum_to_zero(l: list):\n    n = len(l)\n    if n < 3:\n        return False\n    l.sort()\n    for i in range(n - 2):\n        if l[i] > 0:\n            break\n        left, right = i + 1, n - 1\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False",
    "def triples_sum_to_zero(l: list):\n    n = len(l)\n    if n < 3:\n        return False\n    l_sorted = sorted(l)\n    for i in range(n - 2):\n        if l_sorted[i] + l_sorted[i+1] + l_sorted[i+2] > 0:\n            return False\n        if l_sorted[i] + l_sorted[-2] + l_sorted[-1] < 0:\n            continue\n        left, right = i + 1, n - 1\n        while left < right:\n            total = l_sorted[i] + l_sorted[left] + l_sorted[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return False"
  ],
  [
    "def car_race_collision(n: int):\n    return n * n",
    "def car_race_collision(n: int):\n    return n * n",
    "def car_race_collision(n: int):\n    return n * n"
  ],
  [
    "return [x + 1 for x in l]",
    "def incr_list(l: list):\n    return [x + 1 for x in l]",
    "def incr_list(l: list):\n    return [x + 1 for x in l]"
  ],
  [
    "def pairs_sum_to_zero(l):\n    seen = set()\n    for x in l:\n        if -x in seen:\n            return True\n        seen.add(x)\n    return False",
    "def pairs_sum_to_zero(l):\n    seen = set()\n    for x in l:\n        if -x in seen:\n            return True\n        seen.add(x)\n    return False",
    "def pairs_sum_to_zero(l):\n    seen = set()\n    for x in l:\n        if -x in seen:\n            return True\n        seen.add(x)\n    return False"
  ],
  [
    "def change_base(x: int, base: int):\n    if x == 0:\n        return '0'\n    digits = []\n    digits_str = '0123456789'\n    while x:\n        r = x % base\n        digits.append(digits_str[r])\n        x //= base\n    return ''.join(digits[::-1])",
    "def change_base(x: int, base: int):\n    if x == 0:\n        return '0'\n    digits = []\n    while x:\n        x, r = divmod(x, base)\n        digits.append(\"0123456789\"[r])\n    return ''.join(digits[::-1])",
    "def change_base(x: int, base: int):\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x:\n        r = x % base\n        digits.append(chr(ord('0') + r))\n        x //= base\n    return ''.join(digits[::-1])"
  ],
  [
    "def triangle_area(a, h):\n    return a * h / 2",
    "def triangle_area(a, h):\n    return a * h / 2",
    "def triangle_area(a, h):\n    return a * h * 0.5"
  ],
  [
    "def fib4(n: int):\n    if n < 4:\n        return [0, 0, 2, 0][n]\n    a, b, c, d = 0, 0, 2, 0\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d",
    "def fib4(n: int):\n    if n < 4:\n        return [0, 0, 2, 0][n]\n    a, b, c, d = 0, 0, 2, 0\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d",
    "def fib4(n: int):\n    if n < 4:\n        return [0, 0, 2, 0][n]\n    a, b, c, d = 0, 0, 2, 0\n    for _ in range(4, n + 1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d"
  ],
  [
    "import numpy as np\n\ndef median(l: list):\n    arr = np.array(l)\n    median_val = np.median(arr)\n    if len(l) % 2 == 1:\n        return int(median_val)\n    else:\n        return median_val",
    "import numpy as np\n\ndef median(l: list):\n    return np.median(np.array(l))",
    "import numpy as np\n\ndef median(l):\n    arr = np.array(l)\n    median_val = np.median(arr)\n    return int(median_val) if median_val.is_integer() else median_val"
  ],
  [
    "def is_palindrome(text: str):\n    left, right = 0, len(text) - 1\n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    return True",
    "def is_palindrome(text: str):\n    left, right = 0, len(text) - 1\n    while left < right:\n        if text[left] != text[right]:\n            return False\n        left += 1\n        right -= 1\n    return True",
    "def is_palindrome(text: str):\n    n = len(text)\n    for i in range(n // 2):\n        if text[i] != text[n - 1 - i]:\n            return False\n    return True"
  ],
  [
    "def modp(n: int, p: int):\n    return pow(2, n, p)",
    "def modp(n: int, p: int):\n    return pow(2, n, p)",
    "def modp(n: int, p: int):\n    if p == 1:\n        return 0\n    result = 1\n    base = 2\n    while n:\n        if n & 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        n >>= 1\n    return result"
  ],
  [
    "def encode_shift(s: str):\n    a = ord('a')\n    return ''.join(chr((ord(c) - a + 5) % 26 + a) for c in s)\n\ndef decode_shift(s: str):\n    a = ord('a')\n    return ''.join(chr((ord(c) - a - 5) % 26 + a) for c in s)",
    "def encode_shift(s: str):\n    base = ord('a')\n    return ''.join(chr((ord(c) + 5 - base) % 26 + base) for c in s)",
    "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    ord_a = ord('a')\n    return ''.join(chr(((ord(ch) + 5 - ord_a) % 26) + ord_a) for ch in s)"
  ],
  [
    "def remove_vowels(text):\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return ''.join(c for c in text if c not in vowels)",
    "def remove_vowels(text):\n    return text.translate(str.maketrans('', '', 'aeiouAEIOU'))",
    "def remove_vowels(text):\n    return text.translate(str.maketrans('', '', 'aeiouAEIOU'))"
  ],
  [
    "import numpy as np\n\ndef below_threshold(l: list, t: int):\n    arr = np.array(l)\n    return np.all(arr < t)",
    "def below_threshold(l: list, t: int):\n    return all(num < t for num in l)",
    "import numpy as np\n\ndef below_threshold(l: list, t: int):\n    return np.all(np.array(l) < t)"
  ],
  [
    "def add(x: int, y: int):\n    return x + y",
    "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y",
    "def add(x: int, y: int):\n    return x + y"
  ],
  [
    "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)",
    "def same_chars(s0: str, s1: str):\n    if len(s0) != len(s1):\n        return False\n    counts = [0] * 128\n    for c in s0:\n        counts[ord(c)] += 1\n    for c in s1:\n        idx = ord(c)\n        if idx >= 128 or counts[idx] <= 0:\n            return False\n        counts[idx] -= 1\n    return True",
    "import numpy as np\n\ndef same_chars(s0: str, s1: str):\n    arr0 = np.frombuffer(s0.encode(), dtype=np.uint8)\n    arr1 = np.frombuffer(s1.encode(), dtype=np.uint8)\n    mask0 = np.zeros(128, dtype=bool)\n    mask1 = np.zeros(128, dtype=bool)\n    mask0[arr0] = True\n    mask1[arr1] = True\n    return np.array_equal(mask0, mask1)"
  ],
  [
    "def fib(n: int):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
    "def fib(n: int):\n    a, b = 1, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b",
    "import numpy as np\n\ndef fib(n: int):\n    if n == 0:\n        return 0\n    T = np.array([[1, 1], [1, 0]], dtype=np.int64)\n    T = np.linalg.matrix_power(T, n - 1)\n    return T[0, 0]"
  ],
  [
    "def correct_bracketing(brackets: str):\n    count = 0\n    for c in brackets:\n        if c == '<':\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0",
    "def correct_bracketing(brackets: str):\n    count = 0\n    for c in brackets:\n        if c == '<':\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0",
    "def correct_bracketing(brackets: str):\n    count = 0\n    for c in brackets:\n        if c == '<':\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"
  ],
  [
    "def monotonic(l):\n    n = len(l)\n    if n <= 1:\n        return True\n    inc = True\n    dec = True\n    arr = l\n    for i in range(1, n):\n        current = arr[i]\n        prev = arr[i-1]\n        if current > prev:\n            dec = False\n        elif current < prev:\n            inc = False\n        if not inc and not dec:\n            return False\n    return inc or dec",
    "def monotonic(l):\n    if len(l) <= 1:\n        return True\n    inc, dec = True, True\n    prev = l[0]\n    for curr in l[1:]:\n        if curr > prev:\n            dec = False\n        elif curr < prev:\n            inc = False\n        if not inc and not dec:\n            return False\n        prev = curr\n    return inc or dec",
    "def monotonic(l):\n    n = len(l)\n    if n <= 1:\n        return True\n    inc = True\n    dec = True\n    for i in range(1, n):\n        if l[i] > l[i-1]:\n            dec = False\n        elif l[i] < l[i-1]:\n            inc = False\n        if not inc and not dec:\n            return False\n    return inc or dec"
  ],
  [
    "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))",
    "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))",
    "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))"
  ],
  [
    "def largest_prime_factor(n: int):\n    max_factor = 0\n    while n % 2 == 0:\n        max_factor = 2\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            max_factor = f\n            n //= f\n        else:\n            f += 2\n    if n > 1:\n        max_factor = n\n    return max_factor",
    "def largest_prime_factor(n: int):\n    max_factor = 1\n    while n % 2 == 0:\n        max_factor = 2\n        n //= 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            max_factor = i\n            n //= i\n        i += 2\n    if n > 1:\n        max_factor = n\n    return max_factor",
    "def largest_prime_factor(n: int):\n    max_factor = 1\n    while n % 2 == 0:\n        max_factor = 2\n        n //= 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            max_factor = i\n            n //= i\n        else:\n            i += 2\n    if n > 1:\n        max_factor = n\n    return max_factor"
  ],
  [
    "def sum_to_n(n: int):\n    return n * (n + 1) // 2",
    "def sum_to_n(n: int):\n    return n * (n + 1) // 2",
    "def sum_to_n(n: int):\n    return n * (n + 1) // 2"
  ],
  [
    "import numpy as np\n\ndef correct_bracketing(brackets: str):\n    arr = np.array([1 if c == '(' else -1 for c in brackets])\n    prefix = np.cumsum(arr, initial=0)\n    return (prefix >= 0).all() and prefix[-1] == 0",
    "def correct_bracketing(brackets: str):\n    if len(brackets) % 2 != 0:\n        return False\n    count = 0\n    for c in brackets:\n        count += 1 if c == '(' else -1\n        if count < 0:\n            return False\n    return count == 0",
    "def correct_bracketing(brackets: str):\n    count = 0\n    for c in brackets:\n        if c == '(':\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"
  ],
  [
    "def derivative(xs: list):\n    return [i * xs[i] for i in range(1, len(xs))]",
    "import numpy as np\n\ndef derivative(xs):\n    arr = np.array(xs)\n    return (np.arange(1, len(arr)) * arr[1:]).tolist()",
    "def derivative(xs: list):\n    return [i * xs[i] for i in range(1, len(xs))]"
  ],
  [
    "def fibfib(n: int):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c",
    "def fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    if n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c",
    "def fibfib(n: int):\n    if n <= 1:\n        return 0\n    if n == 2:\n        return 1\n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c"
  ],
  [
    "def vowels_count(s):\n    if not s:\n        return 0\n    s_lower = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = sum(1 for c in s_lower if c in vowels)\n    if s_lower[-1] == 'y':\n        count += 1\n    return count",
    "def vowels_count(s):\n    s_lower = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = sum(1 for c in s_lower if c in vowels)\n    if s_lower and s_lower[-1] == 'y':\n        count += 1\n    return count",
    "def vowels_count(s):\n    s_lower = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = sum(1 for c in s_lower if c in vowels)\n    if s_lower and s_lower[-1] == 'y':\n        count += 1\n    return count"
  ],
  [
    "def circular_shift(x, shift):\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    return s[-shift:] + s[:-shift]",
    "def circular_shift(x, shift):\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    return s[-shift:] + s[:-shift]",
    "def circular_shift(x, shift):\n    s = str(x)\n    n = len(s)\n    if shift > n:\n        return s[::-1]\n    else:\n        return s[n - shift:] + s[:n - shift]"
  ],
  [
    "def digitSum(s):\n    return sum(ord(c) for c in s if 'A' <= c <= 'Z')",
    "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())",
    "def digitSum(s):\n    return sum(ord(c) for c in s if c.isupper())"
  ],
  [
    "def fruit_distribution(s,n):\n    parts = s.split()\n    return n - int(parts[0]) - int(parts[3])",
    "def fruit_distribution(s, n):\n    a, b = s.split(' and ', 1)\n    apples = int(a.split()[0])\n    oranges = int(b.split()[0])\n    return n - apples - oranges",
    "def fruit_distribution(s, n):\n    words = s.split()\n    return n - int(words[0]) - int(words[3])"
  ],
  [
    "def pluck(arr):\n    if not arr:\n        return []\n    min_even = None\n    min_index = -1\n    for i, val in enumerate(arr):\n        if (val & 1) == 0 and (min_even is None or val < min_even):\n            min_even = val\n            min_index = i\n    return [min_even, min_index] if min_even else []",
    "def pluck(arr):\n    min_even = None\n    min_index = None\n    for i, x in enumerate(arr):\n        if x % 2 == 0 and (min_even is None or x < min_even):\n            min_even = x\n            min_index = i\n    return [min_even, min_index] if min_even is not None else []",
    "def pluck(arr):\n    min_even = None\n    min_index = None\n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n    return [min_even, min_index] if min_even is not None else []"
  ],
  [
    "def search(lst):\n    n = len(lst)\n    cnt = {}\n    for num in lst:\n        cnt[num] = cnt.get(num, 0) + 1\n    for k in range(n, 0, -1):\n        if k in cnt and cnt[k] >= k:\n            return k\n    return -1",
    "from collections import Counter\n\ndef search(lst):\n    freq = Counter(lst)\n    for num in sorted(freq.keys(), reverse=True):\n        if freq[num] >= num:\n            return num\n    return -1",
    "def search(lst):\n    n = len(lst)\n    freq = [0] * (n + 1)\n    for num in lst:\n        if num <= n:\n            freq[num] += 1\n    for x in range(n, 0, -1):\n        if freq[x] >= x:\n            return x\n    return -1"
  ],
  [
    "def strange_sort_list(lst):\n    sorted_lst = sorted(lst)\n    left, right = 0, len(sorted_lst) - 1\n    result = []\n    while left <= right:\n        result.append(sorted_lst[left])\n        left += 1\n        if left <= right:\n            result.append(sorted_lst[right])\n            right -= 1\n    return result",
    "def strange_sort_list(lst):\n    lst_sorted = sorted(lst)\n    n = len(lst_sorted)\n    return [\n        lst_sorted[i // 2] if i % 2 == 0 else lst_sorted[n - 1 - i // 2]\n        for i in range(n)\n    ]",
    "def strange_sort_list(lst):\n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    while left <= right:\n        result.append(sorted_lst[left])\n        left += 1\n        if left <= right:\n            result.append(sorted_lst[right])\n            right -= 1\n    return result"
  ],
  [
    "import math\n\ndef triangle_area(a, b, c):\n    total = a + b + c\n    max_val = max(a, b, c)\n    if total <= 2 * max_val:\n        return -1\n    s = total / 2.0\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return round(area, 2)",
    "import numpy as np\n\ndef triangle_area(a, b, c):\n    arr = np.array([a, b, c])\n    sorted_arr = np.sort(arr)\n    if sorted_arr[0] + sorted_arr[1] <= sorted_arr[2]:\n        return -1\n    s = np.sum(arr) / 2.0\n    area = np.sqrt(s * (s - arr[0]) * (s - arr[1]) * (s - arr[2]))\n    return round(area, 2)",
    "import math\n\ndef triangle_area(a, b, c):\n    total = a + b + c\n    max_val = max(a, b, c)\n    if total <= 2 * max_val:\n        return -1\n    s = total / 2.0\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return round(area, 2)"
  ],
  [
    "def will_it_fly(q, w):\n    n = len(q)\n    left, right = 0, n - 1\n    while left < right:\n        if q[left] != q[right]:\n            return False\n        left += 1\n        right -= 1\n    return sum(q) <= w",
    "def will_it_fly(q, w):\n    n = len(q)\n    return all(q[i] == q[n - 1 - i] for i in range(n // 2)) and sum(q) <= w",
    "def will_it_fly(q, w):\n    n = len(q)\n    for i in range(n // 2):\n        if q[i] != q[n - 1 - i]:\n            return False\n    return sum(q) <= w"
  ],
  [
    "def smallest_change(arr):\n    n = len(arr)\n    count = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            count += 1\n    return count",
    "def smallest_change(arr):\n    n = len(arr)\n    return sum(1 for i in range(n // 2) if arr[i] != arr[n - 1 - i])",
    "def smallest_change(arr):\n    n = len(arr)\n    return sum(1 for i in range(n // 2) if arr[i] != arr[n - 1 - i])"
  ],
  [
    "def total_match(lst1, lst2):\n    s1 = sum(len(s) for s in lst1)\n    s2 = sum(len(s) for s in lst2)\n    return lst1 if s1 <= s2 else lst2",
    "def total_match(lst1, lst2):\n    total1 = sum(map(len, lst1))\n    total2 = sum(map(len, lst2))\n    return lst1 if total1 <= total2 else lst2",
    "import numpy as np\n\ndef total_match(lst1, lst2):\n    arr1 = np.array(lst1, dtype=object)\n    arr2 = np.array(lst2, dtype=object)\n    total1 = np.char.length(arr1).sum()\n    total2 = np.char.length(arr2).sum()\n    return lst1 if total1 <= total2 else lst2"
  ],
  [
    "def is_multiply_prime(a):\n    if a < 8:\n        return False\n    count = 0\n    temp = a\n    while temp % 2 == 0:\n        count += 1\n        temp //= 2\n        if count > 3:\n            return False\n    f = 3\n    while f * f <= temp:\n        while temp % f == 0:\n            count += 1\n            temp //= f\n            if count > 3:\n                return False\n        f += 2\n    if temp > 1:\n        count += 1\n        if count > 3:\n            return False\n    return count == 3",
    "def is_multiply_prime(a):\n    if a < 2:\n        return False\n    count = 0\n    while a % 2 == 0:\n        count += 1\n        a //= 2\n        if count > 3:\n            return False\n    f = 3\n    while f * f <= a:\n        while a % f == 0:\n            count += 1\n            a //= f\n            if count > 3:\n                return False\n        f += 2\n    if a > 1:\n        count += 1\n    return count == 3",
    "def is_multiply_prime(a):\n    if a < 2:\n        return False\n    count = 0\n    while a % 2 == 0:\n        count += 1\n        a //= 2\n    d = 3\n    while d * d <= a:\n        if a % d == 0:\n            count += 1\n            a //= d\n        else:\n            d += 2\n    if a > 1:\n        count += 1\n    return count == 3"
  ],
  [
    "def is_simple_power(x, n):\n    if x == 1:\n        return True\n    if n == 1:\n        return False\n    current = 1\n    while current < x:\n        current *= n\n        if current == x:\n            return True\n    return False",
    "def is_simple_power(x, n):\n    if x == 1:\n        return True\n    if n == 1:\n        return False\n    current = 1\n    while current < x:\n        current *= n\n        if current == x:\n            return True\n    return False",
    "import numpy as np\n\ndef is_simple_power(x, n):\n    if x == 1:\n        return True\n    if n == 1:\n        return False\n    if n == 0:\n        return x == 0\n    try:\n        k = np.log(x) / np.log(n)\n    except (ValueError, OverflowError):\n        return False\n    k_int = round(k)\n    if abs(k - k_int) < 1e-10:\n        return np.isclose(n**k_int, x)\n    return False"
  ],
  [
    "def iscube(a):\n    if a == 0:\n        return True\n    x = round(a ** (1/3))\n    return x ** 3 == a",
    "def iscube(a):\n    if a == 0:\n        return True\n    abs_a = abs(a)\n    root = round(abs_a ** (1/3))\n    return root ** 3 == abs_a",
    "import numpy as np\n\ndef iscube(a):\n    root = np.cbrt(a)\n    return (np.round(root) ** 3 == a)"
  ],
  [
    "def hex_key(num):\n    prime_hex = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(1 for c in num if c in prime_hex)",
    "def hex_key(num):\n    primes = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(1 for c in num if c in primes)",
    "def hex_key(num):\n    prime_hex = {'2', '3', '5', '7', 'B', 'D'}\n    return sum(c in prime_hex for c in num)"
  ],
  [
    "def decimal_to_binary(decimal):\n    return 'db' + bin(decimal)[2:] + 'db'",
    "def decimal_to_binary(decimal):\n    return 'db' + bin(decimal)[2:] + 'db'",
    "def decimal_to_binary(decimal):\n    return f'db{decimal:b}db'"
  ],
  [
    "def is_happy(s):\n    n = len(s)\n    if n < 3:\n        return False\n    for i in range(n - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True",
    "def is_happy(s):\n    n = len(s)\n    if n < 3:\n        return False\n    for i in range(n - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True",
    "import numpy as np\n\ndef is_happy(s):\n    n = len(s)\n    if n < 3:\n        return False\n    arr = np.array(list(s))\n    eq1 = np.equal(arr[:-1], arr[1:])\n    eq2 = np.equal(arr[:-2], arr[2:])\n    duplicate_mask = eq1[:n-2] | eq2[:n-2] | eq1[1:n-1]\n    return not np.any(duplicate_mask)"
  ],
  [
    "import numpy as np\n\ndef numerical_letter_grade(grades):\n    g = np.array(grades, dtype=float)\n    conditions = [\n        (g == 4.0),\n        (g > 3.7),\n        (g > 3.3),\n        (g > 3.0),\n        (g > 2.7),\n        (g > 2.3),\n        (g > 2.0),\n        (g > 1.7),\n        (g > 1.3),\n        (g > 1.0),\n        (g > 0.7),\n        (g > 0.0)\n    ]\n    choices = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-']\n    return np.select(conditions, choices, default='E').tolist()",
    "import numpy as np\n\ndef numerical_letter_grade(grades):\n    grades_arr = np.array(grades)\n    conditions = [\n        (grades_arr == 4.0),\n        (grades_arr > 3.7),\n        (grades_arr > 3.3),\n        (grades_arr > 3.0),\n        (grades_arr > 2.7),\n        (grades_arr > 2.3),\n        (grades_arr > 2.0),\n        (grades_arr > 1.7),\n        (grades_arr > 1.3),\n        (grades_arr > 1.0),\n        (grades_arr > 0.7),\n        (grades_arr > 0.0)\n    ]\n    choices = [\n        'A+',\n        'A',\n        'A-',\n        'B+',\n        'B',\n        'B-',\n        'C+',\n        'C',\n        'C-',\n        'D+',\n        'D',\n        'D-'\n    ]\n    result = np.select(conditions, choices, default='E')\n    return result.tolist()",
    "def numerical_letter_grade(grades):\n    return [\n        'A+' if g == 4.0 else\n        'A' if g > 3.7 else\n        'A-' if g > 3.3 else\n        'B+' if g > 3.0 else\n        'B' if g > 2.7 else\n        'B-' if g > 2.3 else\n        'C+' if g > 2.0 else\n        'C' if g > 1.7 else\n        'C-' if g > 1.3 else\n        'D+' if g > 1.0 else\n        'D' if g > 0.7 else\n        'D-' if g > 0.0 else 'E'\n        for g in grades\n    ]"
  ],
  [
    "def prime_length(string):\n    n = len(string)\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True",
    "def prime_length(string):\n    n = len(string)\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True",
    "def prime_length(string):\n    n = len(string)\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True"
  ],
  [
    "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    return 18 * (10 ** (n - 2))",
    "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    return 18 * (10 ** (n - 2))",
    "def starts_one_ends(n):\n    if n == 1:\n        return 1\n    return 18 * (10 ** (n - 2))"
  ],
  [
    "def solve(N):\n    total = 0\n    while N:\n        total += N % 10\n        N //= 10\n    return bin(total)[2:]",
    "def solve(N):\n    return bin(sum(map(int, str(N))))[2:]",
    "def solve(N):\n    s = sum(map(int, str(N)))\n    return bin(s)[2:]"
  ],
  [
    "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] & 1 == 0)",
    "def add(lst):\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] & 1 == 0:\n            total += lst[i]\n    return total",
    "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] & 1 == 0)"
  ],
  [
    "def anti_shuffle(s):\n    return ' '.join([''.join(sorted(word)) for word in s.split()])",
    "def anti_shuffle(s):\n    words = s.split()\n    return ' '.join(''.join(sorted(word)) for word in words)",
    "def anti_shuffle(s):\n    words = s.split()\n    res = []\n    for word in words:\n        cnt = [0] * 128\n        for c in word:\n            cnt[ord(c)] += 1\n        res.append(''.join(chr(i) * cnt[i] for i in range(128)))\n    return ' '.join(res)"
  ],
  [
    "def get_row(lst, x):\n    return [(row_idx, col_idx) for row_idx, row in enumerate(lst) for col_idx in range(len(row)-1, -1, -1) if row[col_idx] == x]",
    "def get_row(lst, x):\n    return [\n        (i, j)\n        for i, row in enumerate(lst)\n        for j in reversed(\n            [col for col, val in enumerate(row) if val == x]\n        )\n    ]",
    "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j in range(len(row) - 1, -1, -1):\n            if row[j] == x:\n                result.append((i, j))\n    return result"
  ],
  [
    "def sort_array(array):\n    if not array:\n        return []\n    return sorted(array, reverse=(array[0] & 1) == (array[-1] & 1))",
    "def sort_array(array):\n    if not array:\n        return []\n    first = array[0]\n    last = array[-1]\n    if (first & 1) != (last & 1):\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)",
    "def sort_array(array):\n    if not array:\n        return []\n    if (array[0] + array[-1]) & 1:\n        return sorted(array)\n    return sorted(array, reverse=True)"
  ],
  [
    "import numpy as np\n\ndef encrypt(s):\n    arr = np.frombuffer(s.encode('ascii'), dtype=np.uint8)\n    shifted = (arr - ord('a') + 4) % 26 + ord('a')\n    return shifted.astype(np.uint8).tobytes().decode('ascii')",
    "import string\n\ndef encrypt(s):\n    table = str.maketrans(string.ascii_lowercase, string.ascii_lowercase[4:] + string.ascii_lowercase[:4])\n    return s.translate(table)",
    "def encrypt(s):\n    a = ord('a')\n    return ''.join(chr((ord(c) - a + 4) % 26 + a) for c in s)"
  ],
  [
    "import numpy as np\n\ndef next_smallest(lst):\n    arr = np.array(lst)\n    unique = np.unique(arr)\n    if len(unique) < 2:\n        return None\n    return unique[1]",
    "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    min1 = float('inf')\n    min2 = float('inf')\n    for x in lst:\n        if x < min1:\n            min2 = min1\n            min1 = x\n        elif x < min2 and x != min1:\n            min2 = x\n    return min2 if min2 != float('inf') else None",
    "import numpy as np\n\ndef next_smallest(lst):\n    arr = np.array(lst)\n    if arr.size < 2:\n        return None\n    min_val = np.min(arr)\n    candidates = arr[arr > min_val]\n    if candidates.size == 0:\n        return None\n    return np.min(candidates)"
  ],
  [
    "import re\n\ndef is_bored(S):\n    return len(re.findall(r'(?<=\\s|^)I\\b', S))",
    "def is_bored(S):\n    count = 0\n    start = 0\n    n = len(S)\n    i = 0\n    while i < n:\n        if S[i] in '.!?':\n            sentence = S[start:i].strip()\n            if sentence.startswith('I') and (len(sentence) == 1 or sentence[1] == ' '):\n                count += 1\n            start = i + 1\n            i += 1\n        else:\n            i += 1\n    if start < n:\n        sentence = S[start:].strip()\n        if sentence.startswith('I') and (len(sentence) == 1 or sentence[1] == ' '):\n            count += 1\n    return count",
    "def is_bored(S):\n    count = 0\n    start = 0\n    n = len(S)\n    i = 0\n    delimiters = {'.', '?', '!' }\n    while i < n:\n        if S[i] in delimiters:\n            if S[start] == 'I':\n                if i - start == 1:\n                    count += 1\n                elif i - start > 1 and S[start + 1] == ' ':\n                    count += 1\n            start = i + 1\n        i += 1\n    return count"
  ],
  [
    "def any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        return x == y + z or y == x + z or z == x + y\n    return False",
    "def any_int(x, y, z):\n    if all(isinstance(i, int) for i in (x, y, z)):\n        return (x == y + z) or (y == x + z) or (z == x + y)\n    return False",
    "def any_int(x, y, z):\n    if not all(isinstance(v, int) for v in (x, y, z)):\n        return False\n    s = x + y + z\n    return s == 2 * x or s == 2 * y or s == 2 * z"
  ],
  [
    "def encode(message):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    return ''.join(\n        (vowel_map[c.lower()].upper() if c.isupper() else vowel_map[c.lower()].lower()) if c.lower() in vowels else c\n        for c in (char.swapcase() for char in message)\n    )",
    "def encode(message):\n    vowels = set('aeiou')\n    vowel_map = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    res = []\n    for c in message:\n        if c.islower():\n            c_swapped = c.upper()\n        else:\n            c_swapped = c.lower()\n        c_lower = c_swapped.lower()\n        if c_lower in vowels:\n            char = vowel_map[c_lower]\n            res.append(char.upper() if c_swapped.isupper() else char.lower())\n        else:\n            res.append(c_swapped)\n    return ''.join(res)",
    "def encode(message):\n    trans = str.maketrans('aeiouAEIOU', 'cgekwCGEKW')\n    return message.swapcase().translate(trans)"
  ],
  [
    "def skjkasdkd(lst):\n    lst_sorted = sorted(lst, reverse=True)\n    for num in lst_sorted:\n        if num < 2:\n            continue\n        if num == 2:\n            return 2\n        if num % 2 == 0:\n            continue\n        i = 3\n        while i * i <= num:\n            if num % i == 0:\n                break\n            i += 2\n        else:\n            return sum(int(d) for d in str(num))\n    return 0",
    "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2 or n == 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = None\n    for num in lst:\n        if num > 1 and is_prime(num):\n            if max_prime is None or num > max_prime:\n                max_prime = num\n    total = 0\n    n = max_prime\n    while n:\n        total += n % 10\n        n //= 10\n    return total",
    "def skjkasdkd(lst):\n    max_prime = None\n    for num in lst:\n        if num < 2:\n            continue\n        if num == 2 or num == 3:\n            if max_prime is None or num > max_prime:\n                max_prime = num\n            continue\n        if num % 2 == 0 or num % 3 == 0:\n            continue\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                break\n            i += 6\n        else:\n            if max_prime is None or num > max_prime:\n                max_prime = num\n    if max_prime is None:\n        return 0\n    return sum(int(d) for d in str(max_prime))"
  ],
  [
    "def check_dict_case(dict):\n    if not dict:\n        return False\n    all_lower = True\n    all_upper = True\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if not key.islower():\n            all_lower = False\n        if not key.isupper():\n            all_upper = False\n        if not all_lower and not all_upper:\n            break\n    return all_lower or all_upper",
    "def check_dict_case(dict):\n    if not dict:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n    return all(key.islower() for key in dict) or all(key.isupper() for key in dict)",
    "def check_dict_case(dict):\n    if not dict:\n        return False\n    all_lower = True\n    all_upper = True\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if key.islower():\n            all_upper = False\n        elif key.isupper():\n            all_lower = False\n        else:\n            return False\n    return all_lower or all_upper"
  ],
  [
    "import numpy as np\n\ndef count_up_to(n):\n    if n < 2:\n        return np.array([])\n    sieve = np.ones(n, dtype=bool)\n    sieve[0] = False\n    sieve[1] = False\n    sqrt_n = int(np.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if sieve[i]:\n            sieve[i*i : n : i] = False\n    return np.where(sieve)[0]",
    "import math\n\ndef count_up_to(n):\n    if n < 2:\n        return []\n    sieve = [True] * n\n    sieve[0] = False\n    sieve[1] = False\n    sqrt_n = math.isqrt(n)\n    for i in range(2, sqrt_n + 1):\n        if sieve[i]:\n            for j in range(i * i, n, i):\n                sieve[j] = False\n    return [i for i in range(2, n) if sieve[i]]",
    "import numpy as np\n\ndef count_up_to(n):\n    if n < 2:\n        return np.array([])\n    sieve = np.ones(n, dtype=bool)\n    sieve[0] = False\n    sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            sieve[i*i : n : i] = False\n    return sieve[sieve]"
  ],
  [
    "def multiply(a, b):\n    return (a % 10) * (b % 10)",
    "def multiply(a, b):\n    return (a % 10) * (b % 10)",
    "def multiply(a, b):\n    return (a % 10) * (b % 10)"
  ],
  [
    "import numpy as np\n\ndef count_upper(s):\n    return np.sum(np.isin(np.array(s)[::2], 'AEIOU'))",
    "def count_upper(s):\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    return sum(1 for i in range(0, len(s), 2) if s[i] in vowels)",
    "def count_upper(s):\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    return sum(1 for i in range(0, len(s), 2) if s[i] in vowels)"
  ],
  [
    "def closest_integer(value):\n    num = float(value)\n    if num >= 0:\n        return int(num + 0.5)\n    else:\n        return int(num - 0.5)",
    "def closest_integer(value):\n    x = float(value)\n    return int(x + (0.5 if x >= 0 else -0.5))",
    "def closest_integer(value):\n    n = float(value)\n    return int(n + 0.5) if n >= 0 else int(n - 0.5)"
  ],
  [
    "def make_a_pile(n):\n    return [n + 2 * i for i in range(n)]",
    "def make_a_pile(n):\n    return [n + 2 * i for i in range(n)]",
    "def make_a_pile(n):\n    return list(range(n, 3 * n, 2))"
  ],
  [
    "def words_string(s):\n    return s.replace(',', ' ').split()",
    "def words_string(s):\n    return s.replace(',', ' ').split()",
    "def words_string(s):\n    return s.replace(',', ' ').split()"
  ],
  [
    "def choose_num(x, y):\n    if x > y:\n        return -1\n    candidate = y if y % 2 == 0 else y - 1\n    return candidate if candidate >= x else -1",
    "def choose_num(x, y):\n    if x > y:\n        return -1\n    candidate = (y // 2) * 2\n    return candidate if candidate >= x else -1",
    "def choose_num(x, y):\n    if x > y:\n        return -1\n    candidate = (y // 2) * 2\n    return candidate if candidate >= x else -1"
  ],
  [
    "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    return f\"0b{bin(round((n + m) / 2))[2:]}\"",
    "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    return bin((n + m) // 2)",
    "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    avg = (n + m) / 2\n    rounded_val = round(avg)\n    return bin(rounded_val)"
  ],
  [
    "def unique_digits(x):\n    valid_digits = {'1', '3', '5', '7', '9'}\n    return sorted([num for num in x if all(d in valid_digits for d in str(num))])",
    "def unique_digits(x):\n    odd_digits = {'1', '3', '5', '7', '9'}\n    return sorted([num for num in x if all(d in odd_digits for d in str(num))])",
    "def unique_digits(x):\n    even_digits = {'0', '2', '4', '6', '8'}\n    return sorted([num for num in x if all(d not in even_digits for d in str(num))])"
  ],
  [
    "def by_length(arr):\n    counts = [0] * 10\n    names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    \n    for x in arr:\n        if 1 <= x <= 9:\n            counts[x] += 1\n    \n    sorted_nums = [num for num in range(9, 0, -1) for _ in range(counts[num])]\n    \n    return [names[num-1] for num in sorted_nums]",
    "def by_length(arr):\n    counts = [0] * 10\n    for x in arr:\n        if 1 <= x <= 9:\n            counts[x] += 1\n    result_list = []\n    for num in range(9, 0, -1):\n        result_list.extend([num] * counts[num])\n    names = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    return [names[x] for x in result_list]",
    "def by_length(arr):\n    names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    count = [0] * 10\n    for x in arr:\n        if 1 <= x <= 9:\n            count[x] += 1\n    return [names[i-1] for i in range(9, 0, -1) for _ in range(count[i])]"
  ],
  [
    "def f(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return [fact[k] if k % 2 == 0 else k * (k + 1) // 2 for k in range(1, n + 1)]",
    "def f(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n    return [fact[i] if i % 2 == 0 else i * (i + 1) // 2 for i in range(1, n + 1)]",
    "def f(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i\n    return [fact[i] if i % 2 == 0 else i * (i + 1) // 2 for i in range(1, n + 1)]"
  ],
  [
    "def even_odd_palindrome(n):\n    s = str(n)\n    d = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for m in range(1, d):\n        left_len = (m + 1) // 2\n        count_even_m = 4 * (10 ** (left_len - 1))\n        count_odd_m = 5 * (10 ** (left_len - 1))\n        even_count += count_even_m\n        odd_count += count_odd_m\n        \n    left_len = (d + 1) // 2\n    start = 10 ** (left_len - 1)\n    end = 10 ** left_len\n    \n    for L in range(start, end):\n        s_L = str(L)\n        if d % 2 == 0:\n            p = s_L + s_L[::-1]\n        else:\n            p = s_L + s_L[:-1][::-1]\n        num = int(p)\n        if num > n:\n            break\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    return (even_count, odd_count)",
    "def even_odd_palindrome(n):\n    d_max = len(str(n))\n    even_count = 0\n    odd_count = 0\n\n    for d in range(1, d_max):\n        k = (d + 1) // 2\n        start = 10**(k - 1)\n        end = 10**k - 1\n        for left in range(start, end + 1):\n            s = str(left)\n            if d % 2 == 0:\n                pal_str = s + s[::-1]\n            else:\n                pal_str = s + s[:-1][::-1]\n            num = int(pal_str)\n            even_count += 1 if num % 2 == 0 else 0\n            odd_count += 1 if num % 2 != 0 else 0\n\n    k = (d_max + 1) // 2\n    start = 10**(k - 1)\n    end = 10**k - 1\n    for left in range(start, end + 1):\n        s = str(left)\n        if d_max % 2 == 0:\n            pal_str = s + s[::-1]\n        else:\n            pal_str = s + s[:-1][::-1]\n        num = int(pal_str)\n        if num > n:\n            break\n        even_count += 1 if num % 2 == 0 else 0\n        odd_count += 1 if num % 2 != 0 else 0\n\n    return (even_count, odd_count)",
    "def even_odd_palindrome(n):\n    s_n = str(n)\n    max_digits = len(s_n)\n    even_count = 0\n    odd_count = 0\n    \n    for d in range(1, max_digits):\n        if d % 2 == 0:\n            num = 10 ** (d // 2 - 1)\n            even_count += 4 * num\n            odd_count += 5 * num\n        else:\n            num = 10 ** ((d - 1) // 2)\n            even_count += 4 * num\n            odd_count += 5 * num\n    \n    left_len = (max_digits + 1) // 2\n    start = 10 ** (left_len - 1)\n    end = 10 ** left_len\n    \n    for left in range(start, end):\n        s = str(left)\n        if max_digits % 2 == 0:\n            palindrome_str = s + s[::-1]\n        else:\n            palindrome_str = s + s[:-1][::-1]\n        \n        if palindrome_str <= s_n:\n            if s[0] in '2468':\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)"
  ],
  [
    "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if num > 0:\n            count += 1\n        elif num < 0:\n            m = -num\n            s = 0\n            n = m\n            while n:\n                s += n % 10\n                n //= 10\n            first = m\n            while first >= 10:\n                first //= 10\n            if s - 2 * first > 0:\n                count += 1\n    return count",
    "def count_nums(arr):\n    count = 0\n    for num in arr:\n        s = str(num)\n        if s[0] == '-':\n            total = -int(s[1]) + sum(int(c) for c in s[2:])\n        else:\n            total = sum(int(c) for c in s)\n        if total > 0:\n            count += 1\n    return count",
    "import numpy as np\n\ndef count_nums(arr):\n    arr = np.array(arr)\n    arr_str = np.array([str(x) for x in arr], dtype=object)\n    def compute_sum(s):\n        if s.startswith('-'):\n            rest = s[1:]\n            total_rest = sum(ord(c) for c in rest) - 48 * len(rest)\n            first_digit = ord(s[1]) - 48\n            return total_rest - 2 * first_digit\n        else:\n            return sum(ord(c) for c in s) - 48 * len(s)\n    sums = np.vectorize(compute_sum)(arr_str)\n    return np.sum(sums > 0)"
  ],
  [
    "def move_one_ball(arr):\n    n = len(arr)\n    if n == 0:\n        return True\n    sorted_arr = sorted(arr)\n    min_val = min(arr)\n    m = arr.index(min_val)\n    rotated = arr[m:] + arr[:m]\n    return rotated == sorted_arr",
    "def move_one_ball(arr):\n    n = len(arr)\n    if n == 0:\n        return True\n    m = arr.index(min(arr))\n    \n    for i in range(m, n-1):\n        if arr[i] >= arr[i+1]:\n            return False\n    \n    for i in range(0, m-1):\n        if arr[i] >= arr[i+1]:\n            return False\n    \n    if m > 0 and arr[-1] >= arr[0]:\n        return False\n    \n    return True",
    "def move_one_ball(arr):\n    if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    m = arr.index(min(arr))\n    return arr[m:] + arr[:m] == sorted_arr"
  ],
  [
    "def exchange(lst1, lst2):\n    count_odd = sum(x & 1 for x in lst1)\n    count_even = sum(x & 1 == 0 for x in lst2)\n    return \"YES\" if count_odd <= count_even else \"NO\"",
    "def exchange(lst1, lst2):\n    odd_count = sum(1 for num in lst1 if num % 2 != 0)\n    even_count = sum(1 for num in lst2 if num % 2 == 0)\n    return \"YES\" if even_count >= odd_count else \"NO\"",
    "def exchange(lst1, lst2):\n    num_odds = sum(x % 2 for x in lst1)\n    num_evens = sum(x % 2 == 0 for x in lst2)\n    return \"YES\" if num_odds <= num_evens else \"NO\""
  ],
  [
    "import numpy as np\n\ndef histogram(test):\n    letters = test.split()\n    if not letters:\n        return {}\n    arr = np.array(letters)\n    unique, counts = np.unique(arr, return_counts=True)\n    max_count = counts.max()\n    return {letter: count for letter, count in zip(unique, counts) if count == max_count}",
    "def histogram(test):\n    if not test:\n        return {}\n    count = {}\n    max_count = 0\n    result = {}\n    for char in test:\n        if char == ' ':\n            continue\n        count[char] = count.get(char, 0) + 1\n        if count[char] > max_count:\n            max_count = count[char]\n            result = {char: count[char]}\n        elif count[char] == max_count:\n            result[char] = count[char]\n    return result",
    "from collections import Counter\n\ndef histogram(test):\n    if test == '':\n        return {}\n    counts = Counter(test.split())\n    max_count = max(counts.values())\n    return {k: v for k, v in counts.items() if v == max_count}"
  ],
  [
    "def reverse_delete(s, c):\n    c_set = set(c)\n    filtered = ''.join(char for char in s if char not in c_set)\n    return (filtered, filtered == filtered[::-1])",
    "def reverse_delete(s, c):\n    c_set = set(c)\n    s_clean = ''.join(char for char in s if char not in c_set)\n    return (s_clean, s_clean == s_clean[::-1])",
    "def reverse_delete(s, c):\n    c_set = set(c)\n    filtered = [char for char in s if char not in c_set]\n    res = ''.join(filtered)\n    return (res, res == res[::-1])"
  ],
  [
    "def odd_count(lst):\n    odd_digits = {'1', '3', '5', '7', '9'}\n    return [\n        f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        for s in lst\n        for count in (sum(1 for c in s if c in odd_digits),)\n    ]",
    "def odd_count(lst):\n    odd_digits = {'1', '3', '5', '7', '9'}\n    return [\n        f\"the number of odd elements {c}n the str{c}ng {c} of the {c}nput.\"\n        for s in lst\n        for c in (sum(1 for char in s if char in odd_digits),)\n    ]",
    "def odd_count(lst):\n    odd_digits = {'1', '3', '5', '7', '9'}\n    return [\n        f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        for s in lst\n        for count in (sum(c in odd_digits for c in s),)\n    ]"
  ],
  [
    "def minSubArraySum(nums):\n    current = nums[0]\n    min_sum = nums[0]\n    for num in nums[1:]:\n        current = min(num, current + num)\n        min_sum = min(min_sum, current)\n    return min_sum",
    "def minSubArraySum(nums):\n    current_min = nums[0]\n    min_sum = nums[0]\n    for num in nums[1:]:\n        current_min = min(num, current_min + num)\n        min_sum = min(min_sum, current_min)\n    return min_sum",
    "import numpy as np\n\ndef minSubArraySum(nums):\n    nums_np = np.array(nums)\n    P = np.insert(np.cumsum(nums_np), 0, 0)\n    max_prefix = np.cummax(P)\n    diffs = P[1:] - max_prefix[:-1]\n    return np.min(diffs)"
  ],
  [
    "def max_fill(grid, capacity):\n    return sum((s + capacity - 1) // capacity for s in (sum(row) for row in grid))",
    "import numpy as np\n\ndef max_fill(grid, capacity):\n    arr = np.array(grid)\n    water = arr.sum(axis=1)\n    return sum((w + capacity - 1) // capacity for w in water)",
    "def max_fill(grid, capacity):\n    return sum((sum(row) + capacity - 1) // capacity for row in grid)"
  ],
  [
    "def sort_array(arr):\n    return sorted(arr, key=lambda x: (x.bit_count(), x))",
    "def sort_array(arr):\n    return sorted(arr, key=lambda x: (x.bit_count(), x))",
    "def sort_array(arr):\n    return sorted(arr, key=lambda x: (x.bit_count(), x))"
  ],
  [
    "def select_words(s, n):\n    vowels = set('aeiou')\n    return [word for word in s.split() if len(word) >= n and sum(1 for c in word.lower() if c not in vowels) == n]",
    "def select_words(s, n):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return [word for word in s.split() if len(word) >= n and sum(1 for c in word.lower() if c not in vowels) == n]",
    "def select_words(s, n):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return [word for word in s.split() if sum(1 for c in word.lower() if c not in vowels) == n]"
  ],
  [
    "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    vowel_set = set(vowels)\n    n = len(word)\n    for i in range(n - 2, 0, -1):\n        if word[i] in vowel_set:\n            if word[i - 1] not in vowel_set and word[i + 1] not in vowel_set:\n                return word[i]\n    return \"\"",
    "def get_closest_vowel(word):\n    vowels = set('aeiouAEIOU')\n    n = len(word)\n    for i in range(n-1, 0, -1):\n        if word[i] in vowels:\n            if i == n - 1:\n                continue\n            left_char = word[i-1]\n            right_char = word[i+1]\n            if left_char not in vowels and right_char not in vowels:\n                return word[i]\n    return \"\"",
    "def get_closest_vowel(word):\n    vowels = \"aeiouAEIOU\"\n    vowel_set = set(vowels)\n    n = len(word)\n    if n < 3:\n        return \"\"\n    for i in range(n-2, 0, -1):\n        if word[i] in vowel_set:\n            if word[i-1] not in vowel_set and word[i+1] not in vowel_set:\n                return word[i]\n    return \"\""
  ],
  [
    "def match_parens(lst):\n    s, t = lst[0], lst[1]\n    \n    curr = 0\n    min_s = 0\n    for c in s:\n        curr += 1 if c == '(' else -1\n        min_s = min(min_s, curr)\n    sum_s = curr\n\n    curr = 0\n    min_t = 0\n    for c in t:\n        curr += 1 if c == '(' else -1\n        min_t = min(min_t, curr)\n    sum_t = curr\n\n    if sum_s + sum_t != 0:\n        return 'No'\n    \n    if (min_s >= 0 and sum_s + min_t >= 0) or (min_t >= 0 and sum_t + min_s >= 0):\n        return 'Yes'\n    \n    return 'No'",
    "def match_parens(lst):\n    s1, s2 = lst\n    total1 = 0\n    min1 = 0\n    curr = 0\n    for c in s1:\n        curr += 1 if c == '(' else -1\n        if curr < min1:\n            min1 = curr\n    total1 = curr\n\n    total2 = 0\n    min2 = 0\n    curr = 0\n    for c in s2:\n        curr += 1 if c == '(' else -1\n        if curr < min2:\n            min2 = curr\n    total2 = curr\n\n    if min1 >= 0 and total1 + min2 >= 0 and total1 + total2 == 0:\n        return 'Yes'\n    if min2 >= 0 and total2 + min1 >= 0 and total2 + total1 == 0:\n        return 'Yes'\n    return 'No'",
    "def match_parens(lst):\n    s1, s2 = lst[0], lst[1]\n    total_open = s1.count('(') + s2.count('(')\n    total_close = s1.count(')') + s2.count(')')\n    if total_open != total_close:\n        return 'No'\n    \n    cur = 0\n    min_bal1 = 0\n    for c in s1:\n        if c == '(':\n            cur += 1\n        else:\n            cur -= 1\n        if cur < min_bal1:\n            min_bal1 = cur\n    bal1 = cur\n    \n    cur = 0\n    min_bal2 = 0\n    for c in s2:\n        if c == '(':\n            cur += 1\n        else:\n            cur -= 1\n        if cur < min_bal2:\n            min_bal2 = cur\n    bal2 = cur\n    \n    if (bal1 + min_bal2 >= 0) or (bal2 + min_bal1 >= 0):\n        return 'Yes'\n    return 'No'"
  ],
  [
    "import numpy as np\n\ndef maximum(arr, k):\n    if k == 0:\n        return []\n    arr_np = np.array(arr)\n    sorted_arr = np.sort(arr_np)\n    return sorted_arr[-k:].tolist()",
    "def maximum(arr, k):\n    if k == 0:\n        return []\n    freq = [0] * 2001\n    for num in arr:\n        idx = num + 1000\n        freq[idx] += 1\n    res = []\n    for i in range(2000, -1, -1):\n        if k <= 0:\n            break\n        count = freq[i]\n        take = min(count, k)\n        res.extend([i - 1000] * take)\n        k -= take\n    return res[::-1]",
    "import numpy as np\n\ndef maximum(arr, k):\n    if k == 0:\n        return []\n    arr_np = np.array(arr)\n    sorted_arr = np.sort(arr_np)\n    return sorted_arr[-k:].tolist()"
  ],
  [
    "def solution(lst):\n    total = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] & 1:\n            total += lst[i]\n    return total",
    "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] & 1)",
    "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] & 1)"
  ],
  [
    "from itertools import islice\n\ndef add_elements(arr, k):\n    return sum(x for x in islice(arr, k) if x < 100)",
    "def add_elements(arr, k):\n    return sum(x for x in arr[:k] if x < 100)",
    "import numpy as np\n\ndef add_elements(arr, k):\n    a = np.array(arr[:k])\n    return a[a < 100].sum()"
  ],
  [
    "def get_odd_collatz(n):\n    collatz = []\n    current = n\n    while current != 1:\n        if current & 1 == 0:\n            temp = current\n            while temp & 1 == 0:\n                temp //= 2\n            current = temp\n        else:\n            collatz.append(current)\n            current = 3 * current + 1\n    collatz.append(1)\n    collatz.sort()\n    return collatz",
    "def get_odd_collatz(n):\n    odd_numbers = []\n    current = n\n    while current != 1:\n        if current & 1:\n            odd_numbers.append(current)\n            current = 3 * current + 1\n        else:\n            current >>= 1\n    odd_numbers.append(1)\n    odd_numbers.sort()\n    return odd_numbers",
    "def get_odd_collatz(n):\n    odds = []\n    current = n\n    while current != 1:\n        if current & 1:\n            odds.append(current)\n        current = current >> 1 if current & 1 == 0 else 3 * current + 1\n    odds.append(1)\n    return sorted(odds)"
  ],
  [
    "def valid_date(date):\n    if not date or len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    mm_str, dd_str, yyyy_str = date[:2], date[3:5], date[6:10]\n    if not mm_str.isdigit() or not dd_str.isdigit() or not yyyy_str.isdigit():\n        return False\n    m = int(mm_str)\n    d = int(dd_str)\n    if m < 1 or m > 12:\n        return False\n    days_in_month = (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    return 1 <= d <= days_in_month[m]",
    "def valid_date(date):\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    if not (date[0].isdigit() and date[1].isdigit() and date[3].isdigit() and date[4].isdigit() and date[6].isdigit() and date[7].isdigit() and date[8].isdigit() and date[9].isdigit()):\n        return False\n    m = int(date[0:2])\n    d = int(date[3:5])\n    if m < 1 or m > 12:\n        return False\n    max_days = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if d < 1 or d > max_days[m]:\n        return False\n    return True",
    "def valid_date(date):\n    if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    if not (date[0].isdigit() and date[1].isdigit()):\n        return False\n    if not (date[3].isdigit() and date[4].isdigit()):\n        return False\n    if not (date[6].isdigit() and date[7].isdigit() and date[8].isdigit() and date[9].isdigit()):\n        return False\n    month = int(date[0:2])\n    day = int(date[3:5])\n    if month < 1 or month > 12:\n        return False\n    max_days = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if day < 1 or day > max_days[month]:\n        return False\n    return True"
  ],
  [
    "def split_words(txt):\n    if any(c.isspace() for c in txt):\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower() and (ord(c) & 1) == 0)",
    "def split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        a = ord('a')\n        return sum(1 for c in txt if 'a' <= c <= 'z' and (ord(c) - a) & 1)",
    "def split_words(txt):\n    if any(char.isspace() for char in txt):\n        return txt.split()\n    if ',' in txt:\n        return txt.split(',')\n    odd_chars = {'b', 'd', 'f', 'h', 'j', 'l', 'n', 'p', 'r', 't', 'v', 'x', 'z'}\n    return sum(1 for c in txt if c in odd_chars)"
  ],
  [
    "def is_sorted(lst):\n    n = len(lst)\n    if n == 0:\n        return True\n    current_count = 1\n    for i in range(1, n):\n        if lst[i] < lst[i-1]:\n            return False\n        elif lst[i] == lst[i-1]:\n            current_count += 1\n            if current_count > 2:\n                return False\n        else:\n            current_count = 1\n    return True",
    "def is_sorted(lst):\n    n = len(lst)\n    for i in range(1, n):\n        if lst[i] < lst[i-1]:\n            return False\n        if i >= 2 and lst[i] == lst[i-1] == lst[i-2]:\n            return False\n    return True",
    "def is_sorted(lst):\n    prev = None\n    count = 0\n    for num in lst:\n        if prev is not None and num < prev:\n            return False\n        if num == prev:\n            count += 1\n            if count > 2:\n                return False\n        else:\n            prev = num\n            count = 1\n    return True"
  ],
  [
    "def intersection(interval1, interval2):\n    a, b = interval1\n    c, d = interval2\n    start = max(a, c)\n    end = min(b, d)\n    if start > end:\n        return \"NO\"\n    length = end - start\n    if length < 2:\n        return \"NO\"\n    if length == 2:\n        return \"YES\"\n    if length % 2 == 0:\n        return \"NO\"\n    i = 3\n    while i * i <= length:\n        if length % i == 0:\n            return \"NO\"\n        i += 2\n    return \"YES\"",
    "def intersection(interval1, interval2):\n    s1, e1 = interval1\n    s2, e2 = interval2\n    start = max(s1, s2)\n    end = min(e1, e2)\n    if start > end:\n        return \"NO\"\n    length = end - start\n    if length < 2:\n        return \"NO\"\n    if length == 2:\n        return \"YES\"\n    if length % 2 == 0:\n        return \"NO\"\n    i = 3\n    while i * i <= length:\n        if length % i == 0:\n            return \"NO\"\n        i += 2\n    return \"YES\"",
    "def intersection(interval1, interval2):\n    a, b = interval1\n    c, d = interval2\n    s = max(a, c)\n    e = min(b, d)\n    if s > e:\n        return \"NO\"\n    length = e - s\n    if length < 2:\n        return \"NO\"\n    if length == 2:\n        return \"YES\"\n    if length % 2 == 0:\n        return \"NO\"\n    for i in range(3, int(length**0.5) + 1, 2):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""
  ],
  [
    "def prod_signs(arr):\n    if not arr:\n        return None\n    total = 0\n    sign_product = 1\n    for num in arr:\n        total += abs(num)\n        if num == 0:\n            sign_product = 0\n            break\n        elif num < 0:\n            sign_product *= -1\n    return total * sign_product",
    "def prod_signs(arr):\n    if not arr:\n        return None\n    sum_abs = 0\n    neg_count = 0\n    has_zero = False\n    for x in arr:\n        sum_abs += abs(x)\n        if x == 0:\n            has_zero = True\n        elif x < 0:\n            neg_count += 1\n    return 0 if has_zero else sum_abs * (1 if neg_count % 2 == 0 else -1)",
    "import numpy as np\n\ndef prod_signs(arr):\n    if not arr:\n        return None\n    arr_np = np.array(arr)\n    sum_abs = np.sum(np.abs(arr_np))\n    sign_product = np.prod(np.sign(arr_np))\n    return sum_abs * sign_product"
  ],
  [
    "def minPath(grid, k):\n    N = len(grid)\n    pos = {}\n    for i in range(N):\n        for j in range(N):\n            val = grid[i][j]\n            pos[val] = (i, j)\n    \n    start_i, start_j = pos[1]\n    path = [1]\n    current_i, current_j = start_i, start_j\n    \n    if k == 1:\n        return path\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for _ in range(k-1):\n        min_val = float('inf')\n        min_i, min_j = -1, -1\n        for di, dj in directions:\n            ni = current_i + di\n            nj = current_j + dj\n            if 0 <= ni < N and 0 <= nj < N:\n                val = grid[ni][nj]\n                if val < min_val:\n                    min_val = val\n                    min_i, min_j = ni, nj\n        path.append(min_val)\n        current_i, current_j = min_i, min_j\n    \n    return path",
    "def minPath(grid, k):\n    N = len(grid)\n    start_i, start_j = -1, -1\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                start_i, start_j = i, j\n                break\n        else:\n            continue\n        break\n    \n    path = [1]\n    if k == 1:\n        return path\n    \n    i, j = start_i, start_j\n    for _ in range(k-1):\n        best_val = float('inf')\n        best_i, best_j = -1, -1\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < N and 0 <= nj < N:\n                val = grid[ni][nj]\n                if val < best_val:\n                    best_val = val\n                    best_i, best_j = ni, nj\n        i, j = best_i, best_j\n        path.append(grid[i][j])\n    \n    return path",
    "import numpy as np\n\ndef minPath(grid, k):\n    grid_np = np.array(grid)\n    n = grid_np.shape[0]\n    start_idx = np.argmin(grid_np)\n    start_i, start_j = np.unravel_index(start_idx, grid_np.shape)\n    \n    path = [grid_np[start_i, start_j]]\n    if k == 1:\n        return path\n    \n    cur_i, cur_j = start_i, start_j\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    for _ in range(k-1):\n        neighbors = [\n            (grid_np[ni, nj], ni, nj)\n            for di, dj in directions\n            for ni, nj in [(cur_i + di, cur_j + dj)]\n            if 0 <= ni < n and 0 <= nj < n\n        ]\n        if not neighbors:\n            break\n        min_val, min_i, min_j = min(neighbors)\n        cur_i, cur_j = min_i, min_j\n        path.append(grid_np[cur_i, cur_j])\n    \n    return path"
  ],
  [
    "def tri(n):\n    res = [1]\n    if n >= 1:\n        res.append(3)\n        for i in range(2, n + 1):\n            if i & 1:\n                res.append(res[-1] + res[-2] + (i + 1) // 2 + 1)\n            else:\n                res.append(i // 2 + 1)\n    return res",
    "def tri(n):\n    if n == 0:\n        return [1]\n    res = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            res.append(1 + i // 2)\n        else:\n            next_even = 1 + (i + 1) // 2\n            res.append(res[-1] + res[-2] + next_even)\n    return res",
    "def tri(n):\n    if n == 0:\n        return [1]\n    res = [1, 3]\n    if n == 1:\n        return res\n    for k in range(2, n + 1):\n        if k % 2 == 0:\n            res.append(k // 2 + 1)\n        else:\n            res.append(res[k-1] + res[k-2] + (k + 1) // 2 + 1)\n    return res"
  ],
  [
    "def digits(n):\n    product = 1\n    while n:\n        digit = n % 10\n        if digit & 1:\n            product *= digit\n        n //= 10\n    return product if product != 1 else 0",
    "def digits(n):\n    product = 0\n    while n:\n        digit = n % 10\n        if digit & 1:\n            product = product * digit if product else digit\n        n //= 10\n    return product",
    "def digits(n):\n    product = 0\n    while n:\n        digit = n % 10\n        if digit & 1:\n            product = digit if product == 0 else product * digit\n        n //= 10\n    return product"
  ],
  [
    "def is_nested(string):\n    indices_open = []\n    for i, c in enumerate(string):\n        if c == '[':\n            indices_open.append(i)\n            if len(indices_open) == 2:\n                break\n    indices_close = []\n    for i, c in enumerate(string):\n        if c == ']':\n            indices_close.append(i)\n            if len(indices_close) == 2:\n                break\n    return len(indices_open) >= 2 and len(indices_close) >= 2 and indices_open[1] < indices_close[0]",
    "def is_nested(string):\n    depth = 0\n    max_depth = 0\n    for c in string:\n        if c == '[':\n            depth += 1\n        else:\n            depth -= 1\n        if depth > max_depth:\n            max_depth = depth\n    return max_depth >= 2",
    "def is_nested(string):\n    stack = []\n    for c in string:\n        if c == '[':\n            stack.append(c)\n        else:\n            if stack:\n                stack.pop()\n                if stack:\n                    return True\n    return False"
  ],
  [
    "import numpy as np\n\ndef sum_squares(lst):\n    return np.sum(np.ceil(np.array(lst)).astype(int) ** 2)",
    "import numpy as np\n\ndef sum_squares(lst):\n    return (np.ceil(np.array(lst)).astype(int) ** 2).sum()",
    "import numpy as np\n\ndef sum_squares(lst):\n    return int(np.sum(np.ceil(np.array(lst)) ** 2))"
  ],
  [
    "def check_if_last_char_is_a_letter(txt):\n    return len(txt) > 0 and txt[-1].isalpha() and (len(txt) == 1 or txt[-2] == ' ')",
    "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    if not txt[-1].isalpha():\n        return False\n    if len(txt) > 1 and txt[-2] == ' ':\n        return True\n    return False",
    "def check_if_last_char_is_a_letter(txt):\n    if txt and txt[-1].isalpha() and (len(txt) == 1 or txt[-2] == ' '):\n        return True\n    return False"
  ],
  [
    "import numpy as np\n\ndef can_arrange(arr):\n    if len(arr) < 2:\n        return -1\n    condition = arr[1:] <= arr[:-1]\n    mask_rev = condition[::-1]\n    first_true = np.argmax(mask_rev)\n    if first_true == len(mask_rev):\n        return -1\n    return len(arr) - 1 - first_true",
    "import numpy as np\n\ndef can_arrange(arr):\n    arr_np = np.array(arr)\n    diff = arr_np[1:] - arr_np[:-1]\n    neg_indices = np.where(diff < 0)[0]\n    return neg_indices.max() + 1 if neg_indices.size else -1",
    "def can_arrange(arr):\n    n = len(arr)\n    for i in range(n-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"
  ],
  [
    "def largest_smallest_integers(lst):\n    max_neg = max((x for x in lst if x < 0), default=None)\n    min_pos = min((x for x in lst if x > 0), default=None)\n    return (max_neg, min_pos)",
    "def largest_smallest_integers(lst):\n    largest_neg = None\n    smallest_pos = None\n    for x in lst:\n        if x < 0:\n            if largest_neg is None or x > largest_neg:\n                largest_neg = x\n        elif x > 0:\n            if smallest_pos is None or x < smallest_pos:\n                smallest_pos = x\n    return (largest_neg, smallest_pos)",
    "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n    return (largest_negative, smallest_positive)"
  ],
  [
    "def compare_one(a, b):\n    if isinstance(a, str):\n        a_val = float(a.replace(',', '.'))\n    else:\n        a_val = float(a)\n    \n    if isinstance(b, str):\n        b_val = float(b.replace(',', '.'))\n    else:\n        b_val = float(b)\n    \n    if a_val == b_val:\n        return None\n    elif a_val > b_val:\n        return a\n    else:\n        return b",
    "def compare_one(a, b):\n    a_val = float(a.replace(',', '.')) if isinstance(a, str) else float(a)\n    b_val = float(b.replace(',', '.')) if isinstance(b, str) else float(b)\n    if a_val == b_val:\n        return None\n    return a if a_val > b_val else b",
    "def compare_one(a, b):\n    a_val = float(a.replace(',', '.')) if isinstance(a, str) else float(a)\n    b_val = float(b.replace(',', '.')) if isinstance(b, str) else float(b)\n    if a_val > b_val:\n        return a\n    elif a_val < b_val:\n        return b\n    return None"
  ],
  [
    "def is_equal_to_sum_even(n):\n    return n >= 8 and n % 2 == 0",
    "def is_equal_to_sum_even(n):\n    return n >= 8 and n % 2 == 0",
    "def is_equal_to_sum_even(n):\n    return n >= 8 and n % 2 == 0"
  ],
  [
    "def special_factorial(n):\n    total = 1\n    current = 1\n    for k in range(1, n + 1):\n        current *= k\n        total *= current\n    return total",
    "import numpy as np\n\ndef special_factorial(n):\n    return np.prod(np.cumprod(np.arange(1, n+1)))",
    "def special_factorial(n):\n    result = 1\n    fact = 1\n    for k in range(1, n + 1):\n        fact *= k\n        result *= fact\n    return result"
  ],
  [
    "import re\n\ndef fix_spaces(text):\n    return re.sub(r' +', lambda m: '-' if len(m.group(0)) > 2 else '_' * len(m.group(0)), text)",
    "def fix_spaces(text):\n    result = []\n    current_run = 0\n    for char in text:\n        if char == ' ':\n            current_run += 1\n        else:\n            if current_run > 0:\n                if current_run <= 2:\n                    result.append('_' * current_run)\n                else:\n                    result.append('-')\n            result.append(char)\n            current_run = 0\n    if current_run > 0:\n        if current_run <= 2:\n            result.append('_' * current_run)\n        else:\n            result.append('-')\n    return ''.join(result)",
    "import re\n\ndef fix_spaces(text):\n    return re.sub(r' +', lambda m: '-' if len(m.group(0)) > 2 else '_' * len(m.group(0)), text)"
  ],
  [
    "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.', 1)\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in {'txt', 'exe', 'dll'}:\n        return 'No'\n    return 'Yes' if sum(c.isdigit() for c in file_name) <= 3 else 'No'",
    "def file_name_check(file_name):\n    if file_name.count('.') != 1:\n        return 'No'\n    prefix, suffix = file_name.split('.', 1)\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    if suffix not in {'txt', 'exe', 'dll'}:\n        return 'No'\n    total_digits = 0\n    for c in file_name:\n        if c.isdigit():\n            total_digits += 1\n            if total_digits > 3:\n                return 'No'\n    return 'Yes'",
    "def file_name_check(file_name):\n    n = len(file_name)\n    dot_count = 0\n    dot_index = -1\n    digits_count = 0\n    \n    for i, c in enumerate(file_name):\n        if c == '.':\n            dot_count += 1\n            if dot_count > 1:\n                return 'No'\n            dot_index = i\n        elif c.isdigit():\n            digits_count += 1\n            if digits_count > 3:\n                return 'No'\n    \n    if dot_count != 1:\n        return 'No'\n    \n    if dot_index == 0 or not file_name[0].isalpha():\n        return 'No'\n    \n    after_length = n - dot_index - 1\n    if after_length != 3:\n        return 'No'\n    \n    after_str = file_name[dot_index + 1:dot_index + 4]\n    if after_str not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"
  ],
  [
    "def sum_squares(lst):\n    return sum(x**2 if i % 3 == 0 else x**3 if i % 4 == 0 else x for i, x in enumerate(lst))",
    "import numpy as np\n\ndef sum_squares(lst):\n    a = np.array(lst)\n    idx = np.arange(len(a))\n    mask1 = (idx % 3 == 0)\n    mask2 = (idx % 4 == 0) & (idx % 3 != 0)\n    a[mask1] = a[mask1] ** 2\n    a[mask2] = a[mask2] ** 3\n    return a.sum()",
    "import numpy as np\n\ndef sum_squares(lst):\n    arr = np.array(lst)\n    idx = np.arange(len(arr))\n    mask3 = (idx % 3 == 0)\n    mask4 = (idx % 4 == 0) & ~mask3\n    return np.sum(np.where(mask3, arr**2, np.where(mask4, arr**3, arr)))"
  ],
  [
    "import math\n\ndef words_in_sentence(sentence):\n    n = 1000000\n    sieve = bytearray([1] * (n + 1))\n    sieve[0] = 0\n    sieve[1] = 0\n    sqrt_n = math.isqrt(n)\n    for i in range(2, sqrt_n + 1):\n        if sieve[i]:\n            for j in range(i * i, n + 1, i):\n                sieve[j] = 0\n    words = sentence.split()\n    return \" \".join(word for word in words if sieve[len(word)])",
    "max_n = 1000000\nis_prime = [True] * (max_n + 1)\nis_prime[0] = False\nis_prime[1] = False\nfor i in range(2, int(max_n**0.5) + 1):\n    if is_prime[i]:\n        for j in range(i * i, max_n + 1, i):\n            is_prime[j] = False\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    return ' '.join(word for word in words if is_prime[len(word)])",
    "def words_in_sentence(sentence):\n    max_n = 1000000\n    is_prime = [True] * (max_n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(max_n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, max_n + 1, i):\n                is_prime[j] = False\n    words = sentence.split()\n    return ' '.join(word for word in words if is_prime[len(word)])"
  ],
  [
    "def simplify(x, n):\n    a, b = map(int, x.split('/'))\n    c, d = map(int, n.split('/'))\n    if (a * c) % b == 0:\n        return ((a * c) // b) % d == 0\n    return False",
    "def simplify(x, n):\n    a, b = x.split('/')\n    c, d = n.split('/')\n    return (int(a) * int(c)) % (int(b) * int(d)) == 0",
    "def simplify(x, n):\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    return (x_num * n_num) % (x_den * n_den) == 0"
  ],
  [
    "def order_by_points(nums):\n    def get_sum(x):\n        n = abs(x)\n        s = 0\n        while n:\n            s += n % 10\n            n //= 10\n        return s\n    return sorted(nums, key=get_sum)",
    "def order_by_points(nums):\n    return sorted(nums, key=lambda x: sum(int(d) for d in str(abs(x))))",
    "def order_by_points(nums):\n    def digit_sum(n):\n        n = abs(n)\n        s = 0\n        while n:\n            s += n % 10\n            n //= 10\n        return s\n    return [x for i, x in sorted(enumerate(nums), key=lambda i_x: (digit_sum(i_x[1]), -i_x[0]))]"
  ],
  [
    "def specialFilter(nums):\n    odd_first = {'1', '3', '5', '7', '9'}\n    return sum(1 for num in nums if num > 10 and (num % 10) & 1 and str(num)[0] in odd_first)",
    "def specialFilter(nums):\n    odd_digits = {'1', '3', '5', '7', '9'}\n    return sum(1 for num in nums if num > 10 and (s := str(num))[0] in odd_digits and s[-1] in odd_digits)",
    "def specialFilter(nums):\n    return sum(1 for num in nums if num > 10 and (num % 10) % 2 == 1 and str(num)[0] in '13579')"
  ],
  [
    "def get_max_triples(n):\n    count0 = (n + 1) // 3\n    count1 = n - count0\n    return (count1 * (count1 - 1) * (count1 - 2) // 6) + (count0 * (count0 - 1) * (count0 - 2) // 6)",
    "def get_max_triples(n):\n    c0 = (n + 1) // 3\n    c1 = n - c0\n    return c0 * (c0 - 1) * (c0 - 2) // 6 + c1 * (c1 - 1) * (c1 - 2) // 6",
    "def get_max_triples(n):\n    count0 = (n + 1) // 3\n    count1 = n - count0\n    return (count0 * (count0 - 1) * (count0 - 2) // 6) + (count1 * (count1 - 1) * (count1 - 2) // 6)"
  ],
  [
    "PLANETS = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\nplanet_to_index = {planet: i for i, planet in enumerate(PLANETS)}\n\ndef bf(planet1, planet2):\n    if planet1 not in planet_to_index or planet2 not in planet_to_index:\n        return ()\n    i = planet_to_index[planet1]\n    j = planet_to_index[planet2]\n    start = min(i, j)\n    end = max(i, j)\n    return PLANETS[start+1:end]",
    "def bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    planet_to_index = {planet: i for i, planet in enumerate(planets)}\n    if planet1 not in planet_to_index or planet2 not in planet_to_index:\n        return ()\n    idx1 = planet_to_index[planet1]\n    idx2 = planet_to_index[planet2]\n    start = min(idx1, idx2) + 1\n    end = max(idx1, idx2)\n    return tuple(planets[start:end])",
    "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\nplanet_to_index = {planet: i for i, planet in enumerate(planets)}\n\ndef bf(planet1, planet2):\n    if planet1 not in planet_to_index or planet2 not in planet_to_index:\n        return ()\n    idx1 = planet_to_index[planet1]\n    idx2 = planet_to_index[planet2]\n    start = min(idx1, idx2)\n    end = max(idx1, idx2)\n    return tuple(planets[start+1:end])"
  ],
  [
    "def sorted_list_sum(lst):\n    filtered = [(len(word), word) for word in lst if len(word) % 2 == 0]\n    return [word for _, word in sorted(filtered)]",
    "def sorted_list_sum(lst):\n    return sorted([s for s in lst if len(s) & 1 == 0], key=lambda x: (len(x), x))",
    "def sorted_list_sum(lst):\n    return [s for l, s in sorted((len(s), s) for s in lst if len(s) % 2 == 0)]"
  ],
  [
    "def x_or_y(n, x, y):\n    if n < 2:\n        return y\n    if n == 2 or n == 3:\n        return x\n    if n % 2 == 0 or n % 3 == 0:\n        return y\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return y\n        i += 6\n    return x",
    "def x_or_y(n, x, y):\n    if n < 2:\n        return y\n    if n == 2 or n == 3:\n        return x\n    if n % 2 == 0 or n % 3 == 0:\n        return y\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return y\n        i += 6\n    return x",
    "def x_or_y(n, x, y):\n    if n < 2:\n        return y\n    if n == 2 or n == 3:\n        return x\n    if n % 2 == 0 or n % 3 == 0:\n        return y\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return y\n        i += 6\n    return x"
  ],
  [
    "import numpy as np\n\ndef double_the_difference(lst):\n    arr = np.array(lst)\n    mask = (arr > 0) & (arr % 1 == 0) & (arr % 2 == 1)\n    return np.sum(arr[mask] ** 2)",
    "import numpy as np\n\ndef double_the_difference(lst):\n    arr = np.array(lst)\n    mask = (arr > 0) & (arr.astype(int) == arr) & (arr % 2 == 1)\n    return np.sum(arr[mask] ** 2)",
    "def double_the_difference(lst):\n    return sum(x * x for x in lst if x > 0 and x == int(x) and x % 2 == 1)"
  ],
  [
    "import numpy as np\n\ndef compare(game, guess):\n    return np.abs(np.array(game) - np.array(guess)).tolist()",
    "import numpy as np\n\ndef compare(game, guess):\n    return np.abs(np.array(game) - np.array(guess)).tolist()",
    "import numpy as np\n\ndef compare(game, guess):\n    return np.abs(np.array(game) - np.array(guess)).tolist()"
  ],
  [
    "def Strongest_Extension(class_name, extensions):\n    return f\"{class_name}.{max(extensions, key=lambda ext: 2 * sum(c.isupper() for c in ext) - len(ext))}\"",
    "def Strongest_Extension(class_name, extensions):\n    max_strength = None\n    strongest_extension = None\n    for ext in extensions:\n        strength = sum(1 if c.isupper() else -1 if c.islower() else 0 for c in ext)\n        if max_strength is None or strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f\"{class_name}.{strongest_extension}\"",
    "def Strongest_Extension(class_name, extensions):\n    best_extension = None\n    best_strength = None\n    for ext in extensions:\n        cap_count = sum(1 for c in ext if c.isupper())\n        strength = 2 * cap_count - len(ext)\n        if best_extension is None or strength > best_strength:\n            best_extension = ext\n            best_strength = strength\n    return f\"{class_name}.{best_extension}\""
  ],
  [
    "def cycpattern_check(a, b):\n    n = len(b)\n    m = len(a)\n    if n == 0:\n        return True\n    if n > m:\n        return False\n    for i in range(m - n + 1):\n        substr = a[i:i+n]\n        if b in substr + substr:\n            return True\n    return False",
    "def cycpattern_check(a, b):\n    m = len(b)\n    n = len(a)\n    if m == 0:\n        return True\n    if m > n:\n        return False\n    s = b + b\n    for i in range(m):\n        if s[i:i+m] in a:\n            return True\n    return False",
    "def cycpattern_check(a, b):\n    if len(b) == 0:\n        return True\n    if len(b) > len(a):\n        return False\n    s = b + b\n    m = len(b)\n    for i in range(m):\n        if s[i:i+m] in a:\n            return True\n    return False"
  ],
  [
    "def even_odd_count(num):\n    num = abs(num)\n    if num == 0:\n        return (1, 0)\n    count_even = 0\n    count_odd = 0\n    while num > 0:\n        digit = num % 10\n        num //= 10\n        count_even += 1 - (digit & 1)\n        count_odd += digit & 1\n    return (count_even, count_odd)",
    "def even_odd_count(num):\n    s = str(abs(num))\n    even_set = {'0', '2', '4', '6', '8'}\n    even_count = sum(1 for c in s if c in even_set)\n    return (even_count, len(s) - even_count)",
    "def even_odd_count(num):\n    s = str(abs(num))\n    even_digits = {'0', '2', '4', '6', '8'}\n    even_count = sum(1 for c in s if c in even_digits)\n    return (even_count, len(s) - even_count)"
  ],
  [
    "def int_to_mini_roman(number):\n    roman_numerals = [\n        (1000, 'm'),\n        (900, 'cm'),\n        (500, 'd'),\n        (400, 'cd'),\n        (100, 'c'),\n        (90, 'xc'),\n        (50, 'l'),\n        (40, 'xl'),\n        (10, 'x'),\n        (9, 'ix'),\n        (5, 'v'),\n        (4, 'iv'),\n        (1, 'i')\n    ]\n    res = []\n    for val, sym in roman_numerals:\n        res.append(sym * (number // val))\n        number %= val\n    return ''.join(res)",
    "def int_to_mini_roman(number):\n    val_symbols = [\n        (1000, 'm'),\n        (900, 'cm'),\n        (500, 'd'),\n        (400, 'cd'),\n        (100, 'c'),\n        (90, 'xc'),\n        (50, 'l'),\n        (40, 'xl'),\n        (10, 'x'),\n        (9, 'ix'),\n        (5, 'v'),\n        (4, 'iv'),\n        (1, 'i')\n    ]\n    res = []\n    for val, sym in val_symbols:\n        if number >= val:\n            count = number // val\n            res.append(sym * count)\n            number -= val * count\n    return ''.join(res)",
    "def int_to_mini_roman(number):\n    roman_numerals = [\n        (1000, 'm'),\n        (900, 'cm'),\n        (500, 'd'),\n        (400, 'cd'),\n        (100, 'c'),\n        (90, 'xc'),\n        (50, 'l'),\n        (40, 'xl'),\n        (10, 'x'),\n        (9, 'ix'),\n        (5, 'v'),\n        (4, 'iv'),\n        (1, 'i')\n    ]\n    result = []\n    for value, symbol in roman_numerals:\n        count = number // value\n        result.append(symbol * count)\n        number %= value\n    return ''.join(result)"
  ],
  [
    "def right_angle_triangle(a, b, c):\n    m = max(a, b, c)\n    m_sq = m * m\n    return a*a + b*b + c*c == 2 * m_sq",
    "def right_angle_triangle(a, b, c):\n    if a >= b and a >= c:\n        return a * a == b * b + c * c\n    elif b >= a and b >= c:\n        return b * b == a * a + c * c\n    else:\n        return c * c == a * a + b * b",
    "import numpy as np\n\ndef right_angle_triangle(a, b, c):\n    sq = np.array([a * a, b * b, c * c])\n    return np.sum(sq) == 2 * np.max(sq)"
  ],
  [
    "def find_max(words):\n    return min(words, key=lambda w: (-len(set(w)), w))",
    "def find_max(words):\n    best_word = None\n    max_unique = -1\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique:\n            max_unique = unique_count\n            best_word = word\n        elif unique_count == max_unique:\n            if word < best_word:\n                best_word = word\n    return best_word",
    "def find_max(words):\n    best_word = None\n    best_count = -1\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > best_count:\n            best_count = unique_count\n            best_word = word\n        elif unique_count == best_count and word < best_word:\n            best_word = word\n    return best_word"
  ],
  [
    "def eat(number, need, remaining):\n    m = min(need, remaining)\n    return [number + m, remaining - m]",
    "def eat(number, need, remaining):\n    take = min(need, remaining)\n    return [number + take, remaining - take]",
    "def eat(number, need, remaining):\n    eaten = min(need, remaining)\n    return [number + eaten, remaining - eaten]"
  ],
  [
    "def do_algebra(operator, operand):\n    # Pass 1: exponentiation (**)\n    new_operand = []\n    current = operand[0]\n    for i in range(len(operator)):\n        if operator[i] == '**':\n            current = current ** operand[i+1]\n        else:\n            new_operand.append(current)\n            current = operand[i+1]\n    new_operand.append(current)\n    operand = new_operand\n\n    # Pass 2: multiplication (*) and floor division (//)\n    new_operand = []\n    current = operand[0]\n    for i in range(len(operator)):\n        if operator[i] in ['*', '//']:\n            if operator[i] == '*':\n                current = current * operand[i+1]\n            else:\n                current = current // operand[i+1]\n        else:\n            new_operand.append(current)\n            current = operand[i+1]\n    new_operand.append(current)\n    operand = new_operand\n\n    # Pass 3: addition (+) and subtraction (-)\n    new_operand = []\n    current = operand[0]\n    for i in range(len(operator)):\n        if operator[i] in ['+', '-']:\n            if operator[i] == '+':\n                current = current + operand[i+1]\n            else:\n                current = current - operand[i+1]\n        else:\n            new_operand.append(current)\n            current = operand[i+1]\n    new_operand.append(current)\n    return new_operand[0]",
    "def do_algebra(operator, operand):\n    precedence = {'**': 3, '*': 2, '//': 2, '+': 1, '-': 1}\n    tokens = []\n    for i in range(len(operand)):\n        tokens.append(operand[i])\n        if i < len(operator):\n            tokens.append(operator[i])\n    \n    stack = []\n    rpn = []\n    \n    for token in tokens:\n        if isinstance(token, int):\n            rpn.append(token)\n        else:\n            while stack and stack[-1] != '(' and precedence.get(stack[-1], 0) >= precedence[token]:\n                rpn.append(stack.pop())\n            stack.append(token)\n    \n    while stack:\n        rpn.append(stack.pop())\n    \n    eval_stack = []\n    for token in rpn:\n        if isinstance(token, int):\n            eval_stack.append(token)\n        else:\n            b = eval_stack.pop()\n            a = eval_stack.pop()\n            if token == '+':\n                eval_stack.append(a + b)\n            elif token == '-':\n                eval_stack.append(a - b)\n            elif token == '*':\n                eval_stack.append(a * b)\n            elif token == '//':\n                eval_stack.append(a // b)\n            elif token == '**':\n                eval_stack.append(a ** b)\n    \n    return eval_stack[0]",
    "def do_algebra(operator, operand):\n    tokens = []\n    for num in operand:\n        tokens.append(str(num))\n    for op in operator:\n        tokens.append(op)\n    \n    precedence = {\n        '+': 1,\n        '-': 1,\n        '*': 2,\n        '//': 2,\n        '**': 3\n    }\n    associativity = {\n        '+': 'left',\n        '-': 'left',\n        '*': 'left',\n        '//': 'left',\n        '**': 'right'\n    }\n    output = []\n    stack = []\n    \n    for token in tokens:\n        if token in precedence:\n            while stack and stack[-1] in precedence and (\n                (precedence[stack[-1]] > precedence[token]) or\n                (precedence[stack[-1]] == precedence[token] and associativity[stack[-1]] == 'left')\n            ):\n                output.append(stack.pop())\n            stack.append(token)\n        else:\n            output.append(token)\n    \n    while stack:\n        output.append(stack.pop())\n    \n    op_map = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '//': lambda a, b: a // b,\n        '**': lambda a, b: a ** b\n    }\n    \n    stack = []\n    for token in output:\n        if token in op_map:\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(op_map[token](a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]"
  ],
  [
    "def solve(s):\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return s.swapcase()",
    "def solve(s):\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join([c.swapcase() if c.isalpha() else c for c in s])",
    "def solve(s):\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return s.swapcase()"
  ],
  [
    "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()",
    "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()",
    "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()"
  ],
  [
    "def generate_integers(a, b):\n    low = min(a, b)\n    high = max(a, b)\n    return [x for x in (2, 4, 6, 8) if low <= x <= high]",
    "def generate_integers(a, b):\n    low = min(a, b)\n    high = max(a, b)\n    return [x for x in (2, 4, 6, 8) if low <= x <= high]",
    "def generate_integers(a, b):\n    low = min(a, b)\n    high = max(a, b)\n    candidates = [2, 4, 6, 8]\n    return [d for d in candidates if low <= d <= high]"
  ]
]